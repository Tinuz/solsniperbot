"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_components_MainInterface_tsx",{

/***/ "(app-pages-browser)/./app/hooks/useMintDetection.ts":
/*!***************************************!*\
  !*** ./app/hooks/useMintDetection.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMintDetection: () => (/* binding */ useMintDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_spl_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/spl-token */ \"(app-pages-browser)/./node_modules/@solana/spl-token/lib/esm/constants.js\");\n/* harmony import */ var _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/HeliusConnection */ \"(app-pages-browser)/./app/services/HeliusConnection.ts\");\n/* __next_internal_client_entry_do_not_use__ useMintDetection auto */ \n\n\nconst useMintDetection = (connection, isMonitoring)=>{\n    const [detectedTokens, setDetectedTokens] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [subscriptionId, setSubscriptionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [heartbeatCount, setHeartbeatCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [lastHeartbeat, setLastHeartbeat] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [accountsProcessed, setAccountsProcessed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [pollingResults, setPollingResults] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [intervals, setIntervals] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const processNewToken = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[processNewToken]\": async (logs, context)=>{\n            try {\n                // Count transaction log events\n                setAccountsProcessed({\n                    \"useMintDetection.useCallback[processNewToken]\": (prev)=>prev + 1\n                }[\"useMintDetection.useCallback[processNewToken]\"]);\n                // Check if this transaction contains InitializeMint\n                const hasInit = logs.logs.find({\n                    \"useMintDetection.useCallback[processNewToken].hasInit\": (l)=>l.includes(\"InitializeMint\")\n                }[\"useMintDetection.useCallback[processNewToken].hasInit\"]);\n                if (!hasInit) return;\n                console.log('🔔 InitializeMint detected in slot', logs.slot);\n                console.log('  Signature:', logs.signature);\n                try {\n                    const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                    // Get the parsed transaction with maxSupportedTransactionVersion\n                    console.log('📝 Fetching parsed transaction...');\n                    const parsedTx = await activeConnection.getParsedTransaction(logs.signature, {\n                        commitment: \"confirmed\",\n                        maxSupportedTransactionVersion: 0\n                    });\n                    if (!parsedTx) {\n                        console.warn('⚠️ Parsed transaction not found for signature:', logs.signature);\n                        return;\n                    }\n                    console.log('📄 Parsed transaction retrieved successfully');\n                    console.log('📋 Instructions found:', parsedTx.transaction.message.instructions.length);\n                    // Log all instructions to debug\n                    parsedTx.transaction.message.instructions.forEach({\n                        \"useMintDetection.useCallback[processNewToken]\": (ix, index)=>{\n                            var _ix_parsed, _ix_programId;\n                            console.log(\"  Instruction \".concat(index, \":\"), {\n                                program: ix.program,\n                                parsed: (_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type,\n                                programId: (_ix_programId = ix.programId) === null || _ix_programId === void 0 ? void 0 : _ix_programId.toString()\n                            });\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken]\"]);\n                    // Find the initializeMint instruction\n                    const initInstr = parsedTx.transaction.message.instructions.find({\n                        \"useMintDetection.useCallback[processNewToken].initInstr\": (ix)=>{\n                            var _ix_parsed;\n                            return ix.program === \"spl-token\" && ((_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type) === \"initializeMint\";\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken].initInstr\"]);\n                    if (!initInstr || !initInstr.parsed) {\n                        console.warn('⚠️ initializeMint instruction not found in parsedTx');\n                        console.log('📝 Available spl-token instructions:');\n                        parsedTx.transaction.message.instructions.filter({\n                            \"useMintDetection.useCallback[processNewToken]\": (ix)=>ix.program === \"spl-token\"\n                        }[\"useMintDetection.useCallback[processNewToken]\"]).forEach({\n                            \"useMintDetection.useCallback[processNewToken]\": (ix, index)=>{\n                                var _ix_parsed, _ix_parsed1;\n                                console.log(\"  SPL Token instruction \".concat(index, \":\"), (_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type, (_ix_parsed1 = ix.parsed) === null || _ix_parsed1 === void 0 ? void 0 : _ix_parsed1.info);\n                            }\n                        }[\"useMintDetection.useCallback[processNewToken]\"]);\n                        return;\n                    }\n                    // Extract mint address from parsed info\n                    const mintAddress = initInstr.parsed.info.mint;\n                    console.log('✅ NEW MINT ADDRESS:', mintAddress);\n                    console.log('📋 Full instruction info:', initInstr.parsed.info);\n                    const newToken = {\n                        mint: mintAddress,\n                        timestamp: Date.now(),\n                        signature: logs.signature,\n                        creator: 'InitializeMint',\n                        name: \"Token-\".concat(mintAddress.slice(0, 8)),\n                        symbol: 'NEW',\n                        supply: 0\n                    };\n                    console.log('🔄 Adding token to state:', newToken);\n                    setDetectedTokens({\n                        \"useMintDetection.useCallback[processNewToken]\": (prev)=>{\n                            console.log('📊 Current tokens in state:', prev.length);\n                            const isDuplicate = prev.some({\n                                \"useMintDetection.useCallback[processNewToken].isDuplicate\": (token)=>token.mint === mintAddress\n                            }[\"useMintDetection.useCallback[processNewToken].isDuplicate\"]);\n                            if (isDuplicate) {\n                                console.log('⚠️ Duplicate token detected, skipping:', mintAddress);\n                                return prev;\n                            }\n                            console.log('🎉 NEW TOKEN ADDED TO STATE:', mintAddress);\n                            const newState = [\n                                newToken,\n                                ...prev\n                            ].slice(0, 20);\n                            console.log('📊 New state length:', newState.length);\n                            return newState;\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken]\"]);\n                } catch (error) {\n                    console.log('⚠️ Error processing transaction:', error);\n                }\n            } catch (error) {\n                console.error('Error processing mint detection:', error);\n            }\n        }\n    }[\"useMintDetection.useCallback[processNewToken]\"], [\n        connection\n    ]);\n    // Light polling backup method\n    const pollForNewMints = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[pollForNewMints]\": async ()=>{\n            try {\n                const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                // Check recent signatures (light method)\n                try {\n                    const signatures = await activeConnection.getSignaturesForAddress(_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.TOKEN_PROGRAM_ID, {\n                        limit: 5\n                    });\n                    setPollingResults(signatures.length);\n                } catch (error) {\n                    setPollingResults({\n                        \"useMintDetection.useCallback[pollForNewMints]\": (prev)=>prev + 1\n                    }[\"useMintDetection.useCallback[pollForNewMints]\"]) // Just show activity\n                    ;\n                }\n            } catch (error) {\n            // Silent polling errors\n            }\n        }\n    }[\"useMintDetection.useCallback[pollForNewMints]\"], [\n        connection\n    ]);\n    const startMonitoring = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[startMonitoring]\": async ()=>{\n            if (!isMonitoring || subscriptionId) return;\n            const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n            try {\n                console.log('🔍 Starting mint detection with onLogs...');\n                // Test connection\n                const connectionTest = await _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].testConnection();\n                if (!connectionTest) {\n                    throw new Error('Connection test failed');\n                }\n                // Setup transaction logs listener (more precise than account changes)\n                console.log('📡 Setting up onLogs listener for InitializeMint...');\n                const id = activeConnection.onLogs(_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.TOKEN_PROGRAM_ID, {\n                    \"useMintDetection.useCallback[startMonitoring].id\": (logs, context)=>{\n                        try {\n                            processNewToken(logs, context);\n                        } catch (error) {\n                            console.error('Error in processNewToken:', error);\n                        }\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].id\"], 'confirmed');\n                setSubscriptionId(id);\n                setIsConnected(true);\n                console.log('✅ onLogs monitoring started - ID:', id);\n                console.log('🎯 Listening for InitializeMint transactions');\n                console.log('📊 This method is more precise than account changes');\n                // Heartbeat every 30 seconds\n                const heartbeatInterval = setInterval({\n                    \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": ()=>{\n                        setHeartbeatCount({\n                            \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (prev)=>{\n                                const newCount = prev + 1;\n                                setLastHeartbeat(Date.now());\n                                setAccountsProcessed({\n                                    \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (currentCount)=>{\n                                        setPollingResults({\n                                            \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (currentPollingResults)=>{\n                                                console.log(\"\\uD83D\\uDC93 Heartbeat #\".concat(newCount, \" - \").concat(currentCount, \" transactions, \").concat(currentPollingResults, \" activity\"));\n                                                return currentPollingResults;\n                                            }\n                                        }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                                        return currentCount;\n                                    }\n                                }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                                return newCount;\n                            }\n                        }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"], 30000);\n                // Light polling every 2 minutes\n                const pollingInterval = setInterval({\n                    \"useMintDetection.useCallback[startMonitoring].pollingInterval\": ()=>{\n                        pollForNewMints();\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].pollingInterval\"], 120000);\n                setIntervals({\n                    heartbeat: heartbeatInterval,\n                    polling: pollingInterval\n                });\n                // Initial setup\n                setHeartbeatCount(1);\n                setLastHeartbeat(Date.now());\n                pollForNewMints();\n            } catch (error) {\n                console.error('❌ Failed to start monitoring:', error);\n                setIsConnected(false);\n            }\n        }\n    }[\"useMintDetection.useCallback[startMonitoring]\"], [\n        isMonitoring,\n        subscriptionId,\n        processNewToken,\n        connection,\n        pollForNewMints\n    ]);\n    const stopMonitoring = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[stopMonitoring]\": async ()=>{\n            if (!subscriptionId) return;\n            const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n            try {\n                // Clear intervals\n                if (intervals.heartbeat) clearInterval(intervals.heartbeat);\n                if (intervals.polling) clearInterval(intervals.polling);\n                setIntervals({});\n                // Remove logs subscription\n                activeConnection.removeOnLogsListener(subscriptionId);\n                // Reset state\n                setSubscriptionId(null);\n                setIsConnected(false);\n                setHeartbeatCount(0);\n                setLastHeartbeat(0);\n                setAccountsProcessed(0);\n                setPollingResults(0);\n                console.log('🛑 onLogs monitoring stopped');\n            } catch (error) {\n                console.error('Error stopping monitoring:', error);\n            }\n        }\n    }[\"useMintDetection.useCallback[stopMonitoring]\"], [\n        subscriptionId,\n        connection,\n        intervals\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMintDetection.useEffect\": ()=>{\n            if (isMonitoring) {\n                startMonitoring();\n            } else {\n                stopMonitoring();\n            }\n            return ({\n                \"useMintDetection.useEffect\": ()=>{\n                    // Cleanup on unmount\n                    if (intervals.heartbeat) clearInterval(intervals.heartbeat);\n                    if (intervals.polling) clearInterval(intervals.polling);\n                    if (subscriptionId) {\n                        const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                        activeConnection.removeOnLogsListener(subscriptionId);\n                    }\n                }\n            })[\"useMintDetection.useEffect\"];\n        }\n    }[\"useMintDetection.useEffect\"], [\n        isMonitoring,\n        startMonitoring,\n        stopMonitoring\n    ]);\n    const clearDetectedTokens = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[clearDetectedTokens]\": ()=>{\n            setDetectedTokens([]);\n        }\n    }[\"useMintDetection.useCallback[clearDetectedTokens]\"], []);\n    const removeToken = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[removeToken]\": (mint)=>{\n            setDetectedTokens({\n                \"useMintDetection.useCallback[removeToken]\": (prev)=>prev.filter({\n                        \"useMintDetection.useCallback[removeToken]\": (token)=>token.mint !== mint\n                    }[\"useMintDetection.useCallback[removeToken]\"])\n            }[\"useMintDetection.useCallback[removeToken]\"]);\n        }\n    }[\"useMintDetection.useCallback[removeToken]\"], []);\n    return {\n        detectedTokens,\n        isConnected,\n        isMonitoring: Boolean(subscriptionId),\n        heartbeatCount,\n        lastHeartbeat,\n        accountsProcessed,\n        pollingResults,\n        clearDetectedTokens,\n        removeToken\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9ob29rcy91c2VNaW50RGV0ZWN0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3NFQUV3RDtBQUVKO0FBQ087QUFZcEQsTUFBTUssbUJBQW1CLENBQUNDLFlBQStCQztJQUM5RCxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdSLCtDQUFRQSxDQUFhLEVBQUU7SUFDbkUsTUFBTSxDQUFDUyxnQkFBZ0JDLGtCQUFrQixHQUFHViwrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDVyxhQUFhQyxlQUFlLEdBQUdaLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2EsZ0JBQWdCQyxrQkFBa0IsR0FBR2QsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDZSxlQUFlQyxpQkFBaUIsR0FBR2hCLCtDQUFRQSxDQUFTO0lBQzNELE1BQU0sQ0FBQ2lCLG1CQUFtQkMscUJBQXFCLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUMzRCxNQUFNLENBQUNtQixnQkFBZ0JDLGtCQUFrQixHQUFHcEIsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDcUIsV0FBV0MsYUFBYSxHQUFHdEIsK0NBQVFBLENBQTJELENBQUM7SUFFdEcsTUFBTXVCLGtCQUFrQnRCLGtEQUFXQTt5REFBQyxPQUFPdUIsTUFBV0M7WUFDcEQsSUFBSTtnQkFDRiwrQkFBK0I7Z0JBQy9CUDtxRUFBcUJRLENBQUFBLE9BQVFBLE9BQU87O2dCQUVwQyxvREFBb0Q7Z0JBQ3BELE1BQU1DLFVBQVVILEtBQUtBLElBQUksQ0FBQ0ksSUFBSTs2RUFBQyxDQUFDQyxJQUFjQSxFQUFFQyxRQUFRLENBQUM7O2dCQUN6RCxJQUFJLENBQUNILFNBQVM7Z0JBRWRJLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0NSLEtBQUtTLElBQUk7Z0JBQzNERixRQUFRQyxHQUFHLENBQUMsZ0JBQWdCUixLQUFLVSxTQUFTO2dCQUUxQyxJQUFJO29CQUNGLE1BQU1DLG1CQUFtQjlCLGNBQWNGLGtFQUFnQkEsQ0FBQ2lDLGdCQUFnQjtvQkFFeEUsaUVBQWlFO29CQUNqRUwsUUFBUUMsR0FBRyxDQUFDO29CQUNaLE1BQU1LLFdBQVcsTUFBTUYsaUJBQWlCRyxvQkFBb0IsQ0FDMURkLEtBQUtVLFNBQVMsRUFDZDt3QkFDRUssWUFBWTt3QkFDWkMsZ0NBQWdDO29CQUNsQztvQkFHRixJQUFJLENBQUNILFVBQVU7d0JBQ2JOLFFBQVFVLElBQUksQ0FBQyxrREFBa0RqQixLQUFLVSxTQUFTO3dCQUM3RTtvQkFDRjtvQkFFQUgsUUFBUUMsR0FBRyxDQUFDO29CQUNaRCxRQUFRQyxHQUFHLENBQUMsMEJBQTBCSyxTQUFTSyxXQUFXLENBQUNDLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDQyxNQUFNO29CQUV0RixnQ0FBZ0M7b0JBQ2hDUixTQUFTSyxXQUFXLENBQUNDLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDRSxPQUFPO3lFQUFDLENBQUNDLElBQVNDO2dDQUdoREQsWUFDR0E7NEJBSGJoQixRQUFRQyxHQUFHLENBQUMsaUJBQXVCLE9BQU5nQixPQUFNLE1BQUk7Z0NBQ3JDQyxTQUFTRixHQUFHRSxPQUFPO2dDQUNuQkMsTUFBTSxHQUFFSCxhQUFBQSxHQUFHRyxNQUFNLGNBQVRILGlDQUFBQSxXQUFXSSxJQUFJO2dDQUN2QkMsU0FBUyxHQUFFTCxnQkFBQUEsR0FBR0ssU0FBUyxjQUFaTCxvQ0FBQUEsY0FBY00sUUFBUTs0QkFDbkM7d0JBQ0Y7O29CQUVBLHNDQUFzQztvQkFDdEMsTUFBTUMsWUFBWWpCLFNBQVNLLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDQyxZQUFZLENBQUNoQixJQUFJO21GQUM5RCxDQUFDbUI7Z0NBRUNBO21DQURBQSxHQUFHRSxPQUFPLEtBQUssZUFDZkYsRUFBQUEsYUFBQUEsR0FBR0csTUFBTSxjQUFUSCxpQ0FBQUEsV0FBV0ksSUFBSSxNQUFLOzs7b0JBR3hCLElBQUksQ0FBQ0csYUFBYSxDQUFDQSxVQUFVSixNQUFNLEVBQUU7d0JBQ25DbkIsUUFBUVUsSUFBSSxDQUFDO3dCQUNiVixRQUFRQyxHQUFHLENBQUM7d0JBQ1pLLFNBQVNLLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDQyxZQUFZLENBQ3RDVyxNQUFNOzZFQUFDLENBQUNSLEtBQVlBLEdBQUdFLE9BQU8sS0FBSzs0RUFDbkNILE9BQU87NkVBQUMsQ0FBQ0MsSUFBU0M7b0NBQ2dDRCxZQUFpQkE7Z0NBQWxFaEIsUUFBUUMsR0FBRyxDQUFDLDJCQUFpQyxPQUFOZ0IsT0FBTSxPQUFJRCxhQUFBQSxHQUFHRyxNQUFNLGNBQVRILGlDQUFBQSxXQUFXSSxJQUFJLEdBQUVKLGNBQUFBLEdBQUdHLE1BQU0sY0FBVEgsa0NBQUFBLFlBQVdTLElBQUk7NEJBQ25GOzt3QkFDRjtvQkFDRjtvQkFFQSx3Q0FBd0M7b0JBQ3hDLE1BQU1DLGNBQWNILFVBQVVKLE1BQU0sQ0FBQ00sSUFBSSxDQUFDRSxJQUFJO29CQUM5QzNCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJ5QjtvQkFDbkMxQixRQUFRQyxHQUFHLENBQUMsNkJBQTZCc0IsVUFBVUosTUFBTSxDQUFDTSxJQUFJO29CQUU5RCxNQUFNRyxXQUFxQjt3QkFDekJELE1BQU1EO3dCQUNORyxXQUFXQyxLQUFLQyxHQUFHO3dCQUNuQjVCLFdBQVdWLEtBQUtVLFNBQVM7d0JBQ3pCNkIsU0FBUzt3QkFDVEMsTUFBTSxTQUFpQyxPQUF4QlAsWUFBWVEsS0FBSyxDQUFDLEdBQUc7d0JBQ3BDQyxRQUFRO3dCQUNSQyxRQUFRO29CQUNWO29CQUVBcEMsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QjJCO29CQUV6Q25EO3lFQUFrQmtCLENBQUFBOzRCQUNoQkssUUFBUUMsR0FBRyxDQUFDLCtCQUErQk4sS0FBS21CLE1BQU07NEJBQ3RELE1BQU11QixjQUFjMUMsS0FBSzJDLElBQUk7NkZBQUNDLENBQUFBLFFBQVNBLE1BQU1aLElBQUksS0FBS0Q7OzRCQUN0RCxJQUFJVyxhQUFhO2dDQUNmckMsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ3lCO2dDQUN0RCxPQUFPL0I7NEJBQ1Q7NEJBRUFLLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0N5Qjs0QkFDNUMsTUFBTWMsV0FBVztnQ0FBQ1o7bUNBQWFqQzs2QkFBSyxDQUFDdUMsS0FBSyxDQUFDLEdBQUc7NEJBQzlDbEMsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QnVDLFNBQVMxQixNQUFNOzRCQUNuRCxPQUFPMEI7d0JBQ1Q7O2dCQUVGLEVBQUUsT0FBT0MsT0FBTztvQkFDZHpDLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0N3QztnQkFDbEQ7WUFDRixFQUFFLE9BQU9BLE9BQU87Z0JBQ2R6QyxRQUFReUMsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDcEQ7UUFDRjt3REFBRztRQUFDbkU7S0FBVztJQUVmLDhCQUE4QjtJQUM5QixNQUFNb0Usa0JBQWtCeEUsa0RBQVdBO3lEQUFDO1lBQ2xDLElBQUk7Z0JBQ0YsTUFBTWtDLG1CQUFtQjlCLGNBQWNGLGtFQUFnQkEsQ0FBQ2lDLGdCQUFnQjtnQkFFeEUseUNBQXlDO2dCQUN6QyxJQUFJO29CQUNGLE1BQU1zQyxhQUFhLE1BQU12QyxpQkFBaUJ3Qyx1QkFBdUIsQ0FDL0R6RSwrREFBZ0JBLEVBQ2hCO3dCQUFFMEUsT0FBTztvQkFBRTtvQkFHYnhELGtCQUFrQnNELFdBQVc3QixNQUFNO2dCQUVyQyxFQUFFLE9BQU8yQixPQUFPO29CQUNkcEQ7eUVBQWtCTSxDQUFBQSxPQUFRQSxPQUFPO3dFQUFHLHFCQUFxQjs7Z0JBQzNEO1lBRUYsRUFBRSxPQUFPOEMsT0FBTztZQUNkLHdCQUF3QjtZQUMxQjtRQUNGO3dEQUFHO1FBQUNuRTtLQUFXO0lBRWYsTUFBTXdFLGtCQUFrQjVFLGtEQUFXQTt5REFBQztZQUNsQyxJQUFJLENBQUNLLGdCQUFnQkcsZ0JBQWdCO1lBRXJDLE1BQU0wQixtQkFBbUI5QixjQUFjRixrRUFBZ0JBLENBQUNpQyxnQkFBZ0I7WUFFeEUsSUFBSTtnQkFDRkwsUUFBUUMsR0FBRyxDQUFDO2dCQUVaLGtCQUFrQjtnQkFDbEIsTUFBTThDLGlCQUFpQixNQUFNM0Usa0VBQWdCQSxDQUFDNEUsY0FBYztnQkFDNUQsSUFBSSxDQUFDRCxnQkFBZ0I7b0JBQ25CLE1BQU0sSUFBSUUsTUFBTTtnQkFDbEI7Z0JBRUEsc0VBQXNFO2dCQUN0RWpELFFBQVFDLEdBQUcsQ0FBQztnQkFDWixNQUFNaUQsS0FBSzlDLGlCQUFpQitDLE1BQU0sQ0FDaENoRiwrREFBZ0JBO3dFQUNoQixDQUFDc0IsTUFBV0M7d0JBQ1YsSUFBSTs0QkFDRkYsZ0JBQWdCQyxNQUFNQzt3QkFDeEIsRUFBRSxPQUFPK0MsT0FBTzs0QkFDZHpDLFFBQVF5QyxLQUFLLENBQUMsNkJBQTZCQTt3QkFDN0M7b0JBQ0Y7dUVBQ0E7Z0JBR0Y5RCxrQkFBa0J1RTtnQkFDbEJyRSxlQUFlO2dCQUNmbUIsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQ2lEO2dCQUNqRGxELFFBQVFDLEdBQUcsQ0FBQztnQkFDWkQsUUFBUUMsR0FBRyxDQUFDO2dCQUVaLDZCQUE2QjtnQkFDN0IsTUFBTW1ELG9CQUFvQkM7dUZBQVk7d0JBQ3BDdEU7K0ZBQWtCWSxDQUFBQTtnQ0FDaEIsTUFBTTJELFdBQVczRCxPQUFPO2dDQUN4QlYsaUJBQWlCNkMsS0FBS0MsR0FBRztnQ0FFekI1Qzt1R0FBcUJvRSxDQUFBQTt3Q0FDbkJsRTsrR0FBa0JtRSxDQUFBQTtnREFDaEJ4RCxRQUFRQyxHQUFHLENBQUMsMkJBQStCc0QsT0FBZEQsVUFBUyxPQUFtQ0UsT0FBOUJELGNBQWEsbUJBQXVDLE9BQXRCQyx1QkFBc0I7Z0RBQy9GLE9BQU9BOzRDQUNUOzt3Q0FDQSxPQUFPRDtvQ0FDVDs7Z0NBRUEsT0FBT0Q7NEJBQ1Q7O29CQUNGO3NGQUFHO2dCQUVILGdDQUFnQztnQkFDaEMsTUFBTUcsa0JBQWtCSjtxRkFBWTt3QkFDbENYO29CQUNGO29GQUFHO2dCQUVIbkQsYUFBYTtvQkFBRW1FLFdBQVdOO29CQUFtQk8sU0FBU0Y7Z0JBQWdCO2dCQUV0RSxnQkFBZ0I7Z0JBQ2hCMUUsa0JBQWtCO2dCQUNsQkUsaUJBQWlCNkMsS0FBS0MsR0FBRztnQkFDekJXO1lBRUYsRUFBRSxPQUFPRCxPQUFPO2dCQUNkekMsUUFBUXlDLEtBQUssQ0FBQyxpQ0FBaUNBO2dCQUMvQzVELGVBQWU7WUFDakI7UUFDRjt3REFBRztRQUFDTjtRQUFjRztRQUFnQmM7UUFBaUJsQjtRQUFZb0U7S0FBZ0I7SUFFL0UsTUFBTWtCLGlCQUFpQjFGLGtEQUFXQTt3REFBQztZQUNqQyxJQUFJLENBQUNRLGdCQUFnQjtZQUVyQixNQUFNMEIsbUJBQW1COUIsY0FBY0Ysa0VBQWdCQSxDQUFDaUMsZ0JBQWdCO1lBRXhFLElBQUk7Z0JBQ0Ysa0JBQWtCO2dCQUNsQixJQUFJZixVQUFVb0UsU0FBUyxFQUFFRyxjQUFjdkUsVUFBVW9FLFNBQVM7Z0JBQzFELElBQUlwRSxVQUFVcUUsT0FBTyxFQUFFRSxjQUFjdkUsVUFBVXFFLE9BQU87Z0JBQ3REcEUsYUFBYSxDQUFDO2dCQUVkLDJCQUEyQjtnQkFDM0JhLGlCQUFpQjBELG9CQUFvQixDQUFDcEY7Z0JBRXRDLGNBQWM7Z0JBQ2RDLGtCQUFrQjtnQkFDbEJFLGVBQWU7Z0JBQ2ZFLGtCQUFrQjtnQkFDbEJFLGlCQUFpQjtnQkFDakJFLHFCQUFxQjtnQkFDckJFLGtCQUFrQjtnQkFFbEJXLFFBQVFDLEdBQUcsQ0FBQztZQUNkLEVBQUUsT0FBT3dDLE9BQU87Z0JBQ2R6QyxRQUFReUMsS0FBSyxDQUFDLDhCQUE4QkE7WUFDOUM7UUFDRjt1REFBRztRQUFDL0Q7UUFBZ0JKO1FBQVlnQjtLQUFVO0lBRTFDdEIsZ0RBQVNBO3NDQUFDO1lBQ1IsSUFBSU8sY0FBYztnQkFDaEJ1RTtZQUNGLE9BQU87Z0JBQ0xjO1lBQ0Y7WUFFQTs4Q0FBTztvQkFDTCxxQkFBcUI7b0JBQ3JCLElBQUl0RSxVQUFVb0UsU0FBUyxFQUFFRyxjQUFjdkUsVUFBVW9FLFNBQVM7b0JBQzFELElBQUlwRSxVQUFVcUUsT0FBTyxFQUFFRSxjQUFjdkUsVUFBVXFFLE9BQU87b0JBQ3RELElBQUlqRixnQkFBZ0I7d0JBQ2xCLE1BQU0wQixtQkFBbUI5QixjQUFjRixrRUFBZ0JBLENBQUNpQyxnQkFBZ0I7d0JBQ3hFRCxpQkFBaUIwRCxvQkFBb0IsQ0FBQ3BGO29CQUN4QztnQkFDRjs7UUFDRjtxQ0FBRztRQUFDSDtRQUFjdUU7UUFBaUJjO0tBQWU7SUFFbEQsTUFBTUcsc0JBQXNCN0Ysa0RBQVdBOzZEQUFDO1lBQ3RDTyxrQkFBa0IsRUFBRTtRQUN0Qjs0REFBRyxFQUFFO0lBRUwsTUFBTXVGLGNBQWM5RixrREFBV0E7cURBQUMsQ0FBQ3lEO1lBQy9CbEQ7NkRBQWtCa0IsQ0FBQUEsT0FBUUEsS0FBSzZCLE1BQU07cUVBQUNlLENBQUFBLFFBQVNBLE1BQU1aLElBQUksS0FBS0E7OztRQUNoRTtvREFBRyxFQUFFO0lBRUwsT0FBTztRQUNMbkQ7UUFDQUk7UUFDQUwsY0FBYzBGLFFBQVF2RjtRQUN0Qkk7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQTJFO1FBQ0FDO0lBQ0Y7QUFDRixFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbGVldW0yMS9Eb2N1bWVudHMvUHJvamVjdGVuL0FwcHMvc29sc25pcGVyYm90L2FwcC9ob29rcy91c2VNaW50RGV0ZWN0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5IH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJ1xuaW1wb3J0IHsgVE9LRU5fUFJPR1JBTV9JRCB9IGZyb20gJ0Bzb2xhbmEvc3BsLXRva2VuJ1xuaW1wb3J0IEhlbGl1c0Nvbm5lY3Rpb24gZnJvbSAnLi4vc2VydmljZXMvSGVsaXVzQ29ubmVjdGlvbidcblxuZXhwb3J0IGludGVyZmFjZSBOZXdUb2tlbiB7XG4gIG1pbnQ6IHN0cmluZ1xuICB0aW1lc3RhbXA6IG51bWJlclxuICBzaWduYXR1cmU6IHN0cmluZ1xuICBjcmVhdG9yPzogc3RyaW5nXG4gIG5hbWU/OiBzdHJpbmdcbiAgc3ltYm9sPzogc3RyaW5nXG4gIHN1cHBseT86IG51bWJlclxufVxuXG5leHBvcnQgY29uc3QgdXNlTWludERldGVjdGlvbiA9IChjb25uZWN0aW9uOiBDb25uZWN0aW9uIHwgbnVsbCwgaXNNb25pdG9yaW5nOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IFtkZXRlY3RlZFRva2Vucywgc2V0RGV0ZWN0ZWRUb2tlbnNdID0gdXNlU3RhdGU8TmV3VG9rZW5bXT4oW10pXG4gIGNvbnN0IFtzdWJzY3JpcHRpb25JZCwgc2V0U3Vic2NyaXB0aW9uSWRdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2hlYXJ0YmVhdENvdW50LCBzZXRIZWFydGJlYXRDb3VudF0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCBbbGFzdEhlYXJ0YmVhdCwgc2V0TGFzdEhlYXJ0YmVhdF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApXG4gIGNvbnN0IFthY2NvdW50c1Byb2Nlc3NlZCwgc2V0QWNjb3VudHNQcm9jZXNzZWRdID0gdXNlU3RhdGUoMClcbiAgY29uc3QgW3BvbGxpbmdSZXN1bHRzLCBzZXRQb2xsaW5nUmVzdWx0c10gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCBbaW50ZXJ2YWxzLCBzZXRJbnRlcnZhbHNdID0gdXNlU3RhdGU8eyBoZWFydGJlYXQ/OiBOb2RlSlMuVGltZW91dDsgcG9sbGluZz86IE5vZGVKUy5UaW1lb3V0IH0+KHt9KVxuXG4gIGNvbnN0IHByb2Nlc3NOZXdUb2tlbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChsb2dzOiBhbnksIGNvbnRleHQ6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb3VudCB0cmFuc2FjdGlvbiBsb2cgZXZlbnRzXG4gICAgICBzZXRBY2NvdW50c1Byb2Nlc3NlZChwcmV2ID0+IHByZXYgKyAxKVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHRyYW5zYWN0aW9uIGNvbnRhaW5zIEluaXRpYWxpemVNaW50XG4gICAgICBjb25zdCBoYXNJbml0ID0gbG9ncy5sb2dzLmZpbmQoKGw6IHN0cmluZykgPT4gbC5pbmNsdWRlcyhcIkluaXRpYWxpemVNaW50XCIpKVxuICAgICAgaWYgKCFoYXNJbml0KSByZXR1cm5cblxuICAgICAgY29uc29sZS5sb2coJ/CflJQgSW5pdGlhbGl6ZU1pbnQgZGV0ZWN0ZWQgaW4gc2xvdCcsIGxvZ3Muc2xvdClcbiAgICAgIGNvbnNvbGUubG9nKCcgIFNpZ25hdHVyZTonLCBsb2dzLnNpZ25hdHVyZSlcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWN0aXZlQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb24gfHwgSGVsaXVzQ29ubmVjdGlvbi5nZXRScGNDb25uZWN0aW9uKClcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgcGFyc2VkIHRyYW5zYWN0aW9uIHdpdGggbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIEZldGNoaW5nIHBhcnNlZCB0cmFuc2FjdGlvbi4uLicpXG4gICAgICAgIGNvbnN0IHBhcnNlZFR4ID0gYXdhaXQgYWN0aXZlQ29ubmVjdGlvbi5nZXRQYXJzZWRUcmFuc2FjdGlvbihcbiAgICAgICAgICBsb2dzLnNpZ25hdHVyZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRtZW50OiBcImNvbmZpcm1lZFwiLFxuICAgICAgICAgICAgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uOiAwXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBpZiAoIXBhcnNlZFR4KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gUGFyc2VkIHRyYW5zYWN0aW9uIG5vdCBmb3VuZCBmb3Igc2lnbmF0dXJlOicsIGxvZ3Muc2lnbmF0dXJlKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4QgUGFyc2VkIHRyYW5zYWN0aW9uIHJldHJpZXZlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiyBJbnN0cnVjdGlvbnMgZm91bmQ6JywgcGFyc2VkVHgudHJhbnNhY3Rpb24ubWVzc2FnZS5pbnN0cnVjdGlvbnMubGVuZ3RoKVxuICAgICAgICBcbiAgICAgICAgLy8gTG9nIGFsbCBpbnN0cnVjdGlvbnMgdG8gZGVidWdcbiAgICAgICAgcGFyc2VkVHgudHJhbnNhY3Rpb24ubWVzc2FnZS5pbnN0cnVjdGlvbnMuZm9yRWFjaCgoaXg6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgIEluc3RydWN0aW9uICR7aW5kZXh9OmAsIHtcbiAgICAgICAgICAgIHByb2dyYW06IGl4LnByb2dyYW0sXG4gICAgICAgICAgICBwYXJzZWQ6IGl4LnBhcnNlZD8udHlwZSxcbiAgICAgICAgICAgIHByb2dyYW1JZDogaXgucHJvZ3JhbUlkPy50b1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBGaW5kIHRoZSBpbml0aWFsaXplTWludCBpbnN0cnVjdGlvblxuICAgICAgICBjb25zdCBpbml0SW5zdHIgPSBwYXJzZWRUeC50cmFuc2FjdGlvbi5tZXNzYWdlLmluc3RydWN0aW9ucy5maW5kKFxuICAgICAgICAgIChpeDogYW55KSA9PlxuICAgICAgICAgICAgaXgucHJvZ3JhbSA9PT0gXCJzcGwtdG9rZW5cIiAmJlxuICAgICAgICAgICAgaXgucGFyc2VkPy50eXBlID09PSBcImluaXRpYWxpemVNaW50XCJcbiAgICAgICAgKSBhcyBhbnlcbiAgICAgICAgXG4gICAgICAgIGlmICghaW5pdEluc3RyIHx8ICFpbml0SW5zdHIucGFyc2VkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gaW5pdGlhbGl6ZU1pbnQgaW5zdHJ1Y3Rpb24gbm90IGZvdW5kIGluIHBhcnNlZFR4JylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TnSBBdmFpbGFibGUgc3BsLXRva2VuIGluc3RydWN0aW9uczonKVxuICAgICAgICAgIHBhcnNlZFR4LnRyYW5zYWN0aW9uLm1lc3NhZ2UuaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKChpeDogYW55KSA9PiBpeC5wcm9ncmFtID09PSBcInNwbC10b2tlblwiKVxuICAgICAgICAgICAgLmZvckVhY2goKGl4OiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgU1BMIFRva2VuIGluc3RydWN0aW9uICR7aW5kZXh9OmAsIGl4LnBhcnNlZD8udHlwZSwgaXgucGFyc2VkPy5pbmZvKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJhY3QgbWludCBhZGRyZXNzIGZyb20gcGFyc2VkIGluZm9cbiAgICAgICAgY29uc3QgbWludEFkZHJlc3MgPSBpbml0SW5zdHIucGFyc2VkLmluZm8ubWludCBhcyBzdHJpbmdcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBORVcgTUlOVCBBRERSRVNTOicsIG1pbnRBZGRyZXNzKVxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiyBGdWxsIGluc3RydWN0aW9uIGluZm86JywgaW5pdEluc3RyLnBhcnNlZC5pbmZvKVxuXG4gICAgICAgIGNvbnN0IG5ld1Rva2VuOiBOZXdUb2tlbiA9IHtcbiAgICAgICAgICBtaW50OiBtaW50QWRkcmVzcyxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBsb2dzLnNpZ25hdHVyZSxcbiAgICAgICAgICBjcmVhdG9yOiAnSW5pdGlhbGl6ZU1pbnQnLFxuICAgICAgICAgIG5hbWU6IGBUb2tlbi0ke21pbnRBZGRyZXNzLnNsaWNlKDAsIDgpfWAsXG4gICAgICAgICAgc3ltYm9sOiAnTkVXJyxcbiAgICAgICAgICBzdXBwbHk6IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIEFkZGluZyB0b2tlbiB0byBzdGF0ZTonLCBuZXdUb2tlbilcbiAgICAgICAgXG4gICAgICAgIHNldERldGVjdGVkVG9rZW5zKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEN1cnJlbnQgdG9rZW5zIGluIHN0YXRlOicsIHByZXYubGVuZ3RoKVxuICAgICAgICAgIGNvbnN0IGlzRHVwbGljYXRlID0gcHJldi5zb21lKHRva2VuID0+IHRva2VuLm1pbnQgPT09IG1pbnRBZGRyZXNzKVxuICAgICAgICAgIGlmIChpc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBEdXBsaWNhdGUgdG9rZW4gZGV0ZWN0ZWQsIHNraXBwaW5nOicsIG1pbnRBZGRyZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHByZXZcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfjokgTkVXIFRPS0VOIEFEREVEIFRPIFNUQVRFOicsIG1pbnRBZGRyZXNzKVxuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gW25ld1Rva2VuLCAuLi5wcmV2XS5zbGljZSgwLCAyMClcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBOZXcgc3RhdGUgbGVuZ3RoOicsIG5ld1N0YXRlLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICAgICAgfSlcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBFcnJvciBwcm9jZXNzaW5nIHRyYW5zYWN0aW9uOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIG1pbnQgZGV0ZWN0aW9uOicsIGVycm9yKVxuICAgIH1cbiAgfSwgW2Nvbm5lY3Rpb25dKVxuXG4gIC8vIExpZ2h0IHBvbGxpbmcgYmFja3VwIG1ldGhvZFxuICBjb25zdCBwb2xsRm9yTmV3TWludHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUNvbm5lY3Rpb24gPSBjb25uZWN0aW9uIHx8IEhlbGl1c0Nvbm5lY3Rpb24uZ2V0UnBjQ29ubmVjdGlvbigpXG4gICAgICBcbiAgICAgIC8vIENoZWNrIHJlY2VudCBzaWduYXR1cmVzIChsaWdodCBtZXRob2QpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gYXdhaXQgYWN0aXZlQ29ubmVjdGlvbi5nZXRTaWduYXR1cmVzRm9yQWRkcmVzcyhcbiAgICAgICAgICBUT0tFTl9QUk9HUkFNX0lELFxuICAgICAgICAgIHsgbGltaXQ6IDUgfVxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBzZXRQb2xsaW5nUmVzdWx0cyhzaWduYXR1cmVzLmxlbmd0aClcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZXRQb2xsaW5nUmVzdWx0cyhwcmV2ID0+IHByZXYgKyAxKSAvLyBKdXN0IHNob3cgYWN0aXZpdHlcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBTaWxlbnQgcG9sbGluZyBlcnJvcnNcbiAgICB9XG4gIH0sIFtjb25uZWN0aW9uXSlcblxuICBjb25zdCBzdGFydE1vbml0b3JpbmcgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc01vbml0b3JpbmcgfHwgc3Vic2NyaXB0aW9uSWQpIHJldHVyblxuXG4gICAgY29uc3QgYWN0aXZlQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb24gfHwgSGVsaXVzQ29ubmVjdGlvbi5nZXRScGNDb25uZWN0aW9uKClcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBTdGFydGluZyBtaW50IGRldGVjdGlvbiB3aXRoIG9uTG9ncy4uLicpXG4gICAgICBcbiAgICAgIC8vIFRlc3QgY29ubmVjdGlvblxuICAgICAgY29uc3QgY29ubmVjdGlvblRlc3QgPSBhd2FpdCBIZWxpdXNDb25uZWN0aW9uLnRlc3RDb25uZWN0aW9uKClcbiAgICAgIGlmICghY29ubmVjdGlvblRlc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uIHRlc3QgZmFpbGVkJylcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dXAgdHJhbnNhY3Rpb24gbG9ncyBsaXN0ZW5lciAobW9yZSBwcmVjaXNlIHRoYW4gYWNjb3VudCBjaGFuZ2VzKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk6EgU2V0dGluZyB1cCBvbkxvZ3MgbGlzdGVuZXIgZm9yIEluaXRpYWxpemVNaW50Li4uJylcbiAgICAgIGNvbnN0IGlkID0gYWN0aXZlQ29ubmVjdGlvbi5vbkxvZ3MoXG4gICAgICAgIFRPS0VOX1BST0dSQU1fSUQsXG4gICAgICAgIChsb2dzOiBhbnksIGNvbnRleHQ6IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9jZXNzTmV3VG9rZW4obG9ncywgY29udGV4dClcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcHJvY2Vzc05ld1Rva2VuOicsIGVycm9yKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbmZpcm1lZCdcbiAgICAgIClcblxuICAgICAgc2V0U3Vic2NyaXB0aW9uSWQoaWQpXG4gICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBvbkxvZ3MgbW9uaXRvcmluZyBzdGFydGVkIC0gSUQ6JywgaWQpXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBMaXN0ZW5pbmcgZm9yIEluaXRpYWxpemVNaW50IHRyYW5zYWN0aW9ucycpXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBUaGlzIG1ldGhvZCBpcyBtb3JlIHByZWNpc2UgdGhhbiBhY2NvdW50IGNoYW5nZXMnKVxuICAgICAgXG4gICAgICAvLyBIZWFydGJlYXQgZXZlcnkgMzAgc2Vjb25kc1xuICAgICAgY29uc3QgaGVhcnRiZWF0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHNldEhlYXJ0YmVhdENvdW50KHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0NvdW50ID0gcHJldiArIDFcbiAgICAgICAgICBzZXRMYXN0SGVhcnRiZWF0KERhdGUubm93KCkpXG4gICAgICAgICAgXG4gICAgICAgICAgc2V0QWNjb3VudHNQcm9jZXNzZWQoY3VycmVudENvdW50ID0+IHtcbiAgICAgICAgICAgIHNldFBvbGxpbmdSZXN1bHRzKGN1cnJlbnRQb2xsaW5nUmVzdWx0cyA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5KTIEhlYXJ0YmVhdCAjJHtuZXdDb3VudH0gLSAke2N1cnJlbnRDb3VudH0gdHJhbnNhY3Rpb25zLCAke2N1cnJlbnRQb2xsaW5nUmVzdWx0c30gYWN0aXZpdHlgKVxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFBvbGxpbmdSZXN1bHRzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb3VudFxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG5ld0NvdW50XG4gICAgICAgIH0pXG4gICAgICB9LCAzMDAwMClcblxuICAgICAgLy8gTGlnaHQgcG9sbGluZyBldmVyeSAyIG1pbnV0ZXNcbiAgICAgIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgcG9sbEZvck5ld01pbnRzKClcbiAgICAgIH0sIDEyMDAwMClcblxuICAgICAgc2V0SW50ZXJ2YWxzKHsgaGVhcnRiZWF0OiBoZWFydGJlYXRJbnRlcnZhbCwgcG9sbGluZzogcG9sbGluZ0ludGVydmFsIH0pXG4gICAgICBcbiAgICAgIC8vIEluaXRpYWwgc2V0dXBcbiAgICAgIHNldEhlYXJ0YmVhdENvdW50KDEpXG4gICAgICBzZXRMYXN0SGVhcnRiZWF0KERhdGUubm93KCkpXG4gICAgICBwb2xsRm9yTmV3TWludHMoKVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RhcnQgbW9uaXRvcmluZzonLCBlcnJvcilcbiAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxuICAgIH1cbiAgfSwgW2lzTW9uaXRvcmluZywgc3Vic2NyaXB0aW9uSWQsIHByb2Nlc3NOZXdUb2tlbiwgY29ubmVjdGlvbiwgcG9sbEZvck5ld01pbnRzXSlcblxuICBjb25zdCBzdG9wTW9uaXRvcmluZyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbklkKSByZXR1cm5cblxuICAgIGNvbnN0IGFjdGl2ZUNvbm5lY3Rpb24gPSBjb25uZWN0aW9uIHx8IEhlbGl1c0Nvbm5lY3Rpb24uZ2V0UnBjQ29ubmVjdGlvbigpXG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2xlYXIgaW50ZXJ2YWxzXG4gICAgICBpZiAoaW50ZXJ2YWxzLmhlYXJ0YmVhdCkgY2xlYXJJbnRlcnZhbChpbnRlcnZhbHMuaGVhcnRiZWF0KVxuICAgICAgaWYgKGludGVydmFscy5wb2xsaW5nKSBjbGVhckludGVydmFsKGludGVydmFscy5wb2xsaW5nKVxuICAgICAgc2V0SW50ZXJ2YWxzKHt9KVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgbG9ncyBzdWJzY3JpcHRpb25cbiAgICAgIGFjdGl2ZUNvbm5lY3Rpb24ucmVtb3ZlT25Mb2dzTGlzdGVuZXIoc3Vic2NyaXB0aW9uSWQpXG4gICAgICBcbiAgICAgIC8vIFJlc2V0IHN0YXRlXG4gICAgICBzZXRTdWJzY3JpcHRpb25JZChudWxsKVxuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXG4gICAgICBzZXRIZWFydGJlYXRDb3VudCgwKVxuICAgICAgc2V0TGFzdEhlYXJ0YmVhdCgwKVxuICAgICAgc2V0QWNjb3VudHNQcm9jZXNzZWQoMClcbiAgICAgIHNldFBvbGxpbmdSZXN1bHRzKDApXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5uRIG9uTG9ncyBtb25pdG9yaW5nIHN0b3BwZWQnKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdG9wcGluZyBtb25pdG9yaW5nOicsIGVycm9yKVxuICAgIH1cbiAgfSwgW3N1YnNjcmlwdGlvbklkLCBjb25uZWN0aW9uLCBpbnRlcnZhbHNdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzTW9uaXRvcmluZykge1xuICAgICAgc3RhcnRNb25pdG9yaW5nKClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcE1vbml0b3JpbmcoKVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbnVwIG9uIHVubW91bnRcbiAgICAgIGlmIChpbnRlcnZhbHMuaGVhcnRiZWF0KSBjbGVhckludGVydmFsKGludGVydmFscy5oZWFydGJlYXQpXG4gICAgICBpZiAoaW50ZXJ2YWxzLnBvbGxpbmcpIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxzLnBvbGxpbmcpXG4gICAgICBpZiAoc3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb24gfHwgSGVsaXVzQ29ubmVjdGlvbi5nZXRScGNDb25uZWN0aW9uKClcbiAgICAgICAgYWN0aXZlQ29ubmVjdGlvbi5yZW1vdmVPbkxvZ3NMaXN0ZW5lcihzdWJzY3JpcHRpb25JZClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpc01vbml0b3JpbmcsIHN0YXJ0TW9uaXRvcmluZywgc3RvcE1vbml0b3JpbmddKVxuXG4gIGNvbnN0IGNsZWFyRGV0ZWN0ZWRUb2tlbnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0RGV0ZWN0ZWRUb2tlbnMoW10pXG4gIH0sIFtdKVxuXG4gIGNvbnN0IHJlbW92ZVRva2VuID0gdXNlQ2FsbGJhY2soKG1pbnQ6IHN0cmluZykgPT4ge1xuICAgIHNldERldGVjdGVkVG9rZW5zKHByZXYgPT4gcHJldi5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubWludCAhPT0gbWludCkpXG4gIH0sIFtdKVxuXG4gIHJldHVybiB7XG4gICAgZGV0ZWN0ZWRUb2tlbnMsXG4gICAgaXNDb25uZWN0ZWQsXG4gICAgaXNNb25pdG9yaW5nOiBCb29sZWFuKHN1YnNjcmlwdGlvbklkKSxcbiAgICBoZWFydGJlYXRDb3VudCxcbiAgICBsYXN0SGVhcnRiZWF0LFxuICAgIGFjY291bnRzUHJvY2Vzc2VkLFxuICAgIHBvbGxpbmdSZXN1bHRzLFxuICAgIGNsZWFyRGV0ZWN0ZWRUb2tlbnMsXG4gICAgcmVtb3ZlVG9rZW5cbiAgfVxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiVE9LRU5fUFJPR1JBTV9JRCIsIkhlbGl1c0Nvbm5lY3Rpb24iLCJ1c2VNaW50RGV0ZWN0aW9uIiwiY29ubmVjdGlvbiIsImlzTW9uaXRvcmluZyIsImRldGVjdGVkVG9rZW5zIiwic2V0RGV0ZWN0ZWRUb2tlbnMiLCJzdWJzY3JpcHRpb25JZCIsInNldFN1YnNjcmlwdGlvbklkIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImhlYXJ0YmVhdENvdW50Iiwic2V0SGVhcnRiZWF0Q291bnQiLCJsYXN0SGVhcnRiZWF0Iiwic2V0TGFzdEhlYXJ0YmVhdCIsImFjY291bnRzUHJvY2Vzc2VkIiwic2V0QWNjb3VudHNQcm9jZXNzZWQiLCJwb2xsaW5nUmVzdWx0cyIsInNldFBvbGxpbmdSZXN1bHRzIiwiaW50ZXJ2YWxzIiwic2V0SW50ZXJ2YWxzIiwicHJvY2Vzc05ld1Rva2VuIiwibG9ncyIsImNvbnRleHQiLCJwcmV2IiwiaGFzSW5pdCIsImZpbmQiLCJsIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwibG9nIiwic2xvdCIsInNpZ25hdHVyZSIsImFjdGl2ZUNvbm5lY3Rpb24iLCJnZXRScGNDb25uZWN0aW9uIiwicGFyc2VkVHgiLCJnZXRQYXJzZWRUcmFuc2FjdGlvbiIsImNvbW1pdG1lbnQiLCJtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb24iLCJ3YXJuIiwidHJhbnNhY3Rpb24iLCJtZXNzYWdlIiwiaW5zdHJ1Y3Rpb25zIiwibGVuZ3RoIiwiZm9yRWFjaCIsIml4IiwiaW5kZXgiLCJwcm9ncmFtIiwicGFyc2VkIiwidHlwZSIsInByb2dyYW1JZCIsInRvU3RyaW5nIiwiaW5pdEluc3RyIiwiZmlsdGVyIiwiaW5mbyIsIm1pbnRBZGRyZXNzIiwibWludCIsIm5ld1Rva2VuIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImNyZWF0b3IiLCJuYW1lIiwic2xpY2UiLCJzeW1ib2wiLCJzdXBwbHkiLCJpc0R1cGxpY2F0ZSIsInNvbWUiLCJ0b2tlbiIsIm5ld1N0YXRlIiwiZXJyb3IiLCJwb2xsRm9yTmV3TWludHMiLCJzaWduYXR1cmVzIiwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJsaW1pdCIsInN0YXJ0TW9uaXRvcmluZyIsImNvbm5lY3Rpb25UZXN0IiwidGVzdENvbm5lY3Rpb24iLCJFcnJvciIsImlkIiwib25Mb2dzIiwiaGVhcnRiZWF0SW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsIm5ld0NvdW50IiwiY3VycmVudENvdW50IiwiY3VycmVudFBvbGxpbmdSZXN1bHRzIiwicG9sbGluZ0ludGVydmFsIiwiaGVhcnRiZWF0IiwicG9sbGluZyIsInN0b3BNb25pdG9yaW5nIiwiY2xlYXJJbnRlcnZhbCIsInJlbW92ZU9uTG9nc0xpc3RlbmVyIiwiY2xlYXJEZXRlY3RlZFRva2VucyIsInJlbW92ZVRva2VuIiwiQm9vbGVhbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/hooks/useMintDetection.ts\n"));

/***/ })

});