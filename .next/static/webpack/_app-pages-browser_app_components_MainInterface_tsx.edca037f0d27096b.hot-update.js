"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_components_MainInterface_tsx",{

/***/ "(app-pages-browser)/./app/hooks/useMintDetection.ts":
/*!***************************************!*\
  !*** ./app/hooks/useMintDetection.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMintDetection: () => (/* binding */ useMintDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_spl_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/spl-token */ \"(app-pages-browser)/./node_modules/@solana/spl-token/lib/esm/constants.js\");\n/* harmony import */ var _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/HeliusConnection */ \"(app-pages-browser)/./app/services/HeliusConnection.ts\");\n/* __next_internal_client_entry_do_not_use__ useMintDetection auto */ \n\n\nconst useMintDetection = (connection, isMonitoring)=>{\n    const [detectedTokens, setDetectedTokens] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [subscriptionId, setSubscriptionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [heartbeatCount, setHeartbeatCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [lastHeartbeat, setLastHeartbeat] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [accountsProcessed, setAccountsProcessed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [pollingResults, setPollingResults] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [intervals, setIntervals] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const processNewToken = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[processNewToken]\": async (logs, context)=>{\n            try {\n                // Count transaction log events\n                setAccountsProcessed({\n                    \"useMintDetection.useCallback[processNewToken]\": (prev)=>prev + 1\n                }[\"useMintDetection.useCallback[processNewToken]\"]);\n                // Check if this transaction contains InitializeMint\n                const hasInit = logs.logs.find({\n                    \"useMintDetection.useCallback[processNewToken].hasInit\": (l)=>l.includes(\"InitializeMint\")\n                }[\"useMintDetection.useCallback[processNewToken].hasInit\"]);\n                if (!hasInit) return;\n                console.log('ðŸ”” InitializeMint detected in slot', logs.slot);\n                console.log('  Signature:', logs.signature);\n                try {\n                    const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                    // Get the parsed transaction with maxSupportedTransactionVersion\n                    console.log('ðŸ“ Fetching parsed transaction...');\n                    const parsedTx = await activeConnection.getParsedTransaction(logs.signature, {\n                        commitment: \"confirmed\",\n                        maxSupportedTransactionVersion: 0\n                    });\n                    if (!parsedTx) {\n                        console.warn('âš ï¸ Parsed transaction not found for signature:', logs.signature);\n                        return;\n                    }\n                    console.log('ðŸ“„ Parsed transaction retrieved successfully');\n                    console.log('ðŸ“‹ Instructions found:', parsedTx.transaction.message.instructions.length);\n                    // Log all instructions to debug\n                    parsedTx.transaction.message.instructions.forEach({\n                        \"useMintDetection.useCallback[processNewToken]\": (ix, index)=>{\n                            var _ix_parsed, _ix_programId;\n                            console.log(\"  Instruction \".concat(index, \":\"), {\n                                program: ix.program,\n                                parsed: (_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type,\n                                programId: (_ix_programId = ix.programId) === null || _ix_programId === void 0 ? void 0 : _ix_programId.toString()\n                            });\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken]\"]);\n                    // Find the initializeMint instruction\n                    const initInstr = parsedTx.transaction.message.instructions.find({\n                        \"useMintDetection.useCallback[processNewToken].initInstr\": (ix)=>{\n                            var _ix_parsed;\n                            return ix.program === \"spl-token\" && ((_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type) === \"initializeMint\";\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken].initInstr\"]);\n                    if (!initInstr || !initInstr.parsed) {\n                        console.warn('âš ï¸ initializeMint instruction not found in parsedTx');\n                        console.log('ðŸ“ Available spl-token instructions:');\n                        parsedTx.transaction.message.instructions.filter({\n                            \"useMintDetection.useCallback[processNewToken]\": (ix)=>ix.program === \"spl-token\"\n                        }[\"useMintDetection.useCallback[processNewToken]\"]).forEach({\n                            \"useMintDetection.useCallback[processNewToken]\": (ix, index)=>{\n                                var _ix_parsed, _ix_parsed1;\n                                console.log(\"  SPL Token instruction \".concat(index, \":\"), (_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type, (_ix_parsed1 = ix.parsed) === null || _ix_parsed1 === void 0 ? void 0 : _ix_parsed1.info);\n                            }\n                        }[\"useMintDetection.useCallback[processNewToken]\"]);\n                        return;\n                    }\n                    // Extract mint address from parsed info\n                    const mintAddress = initInstr.parsed.info.mint;\n                    console.log('âœ… NEW MINT ADDRESS:', mintAddress);\n                    const newToken = {\n                        mint: mintAddress,\n                        timestamp: Date.now(),\n                        signature: logs.signature,\n                        creator: 'InitializeMint',\n                        name: \"Token-\".concat(mintAddress.slice(0, 8)),\n                        symbol: 'NEW',\n                        supply: 0\n                    };\n                    setDetectedTokens({\n                        \"useMintDetection.useCallback[processNewToken]\": (prev)=>{\n                            const isDuplicate = prev.some({\n                                \"useMintDetection.useCallback[processNewToken].isDuplicate\": (token)=>token.mint === mintAddress\n                            }[\"useMintDetection.useCallback[processNewToken].isDuplicate\"]);\n                            if (isDuplicate) return prev;\n                            console.log('ðŸŽ‰ NEW TOKEN ADDED:', mintAddress);\n                            return [\n                                newToken,\n                                ...prev\n                            ].slice(0, 20);\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken]\"]);\n                } catch (error) {\n                    console.log('âš ï¸ Error processing transaction:', error);\n                }\n            } catch (error) {\n                console.error('Error processing mint detection:', error);\n            }\n        }\n    }[\"useMintDetection.useCallback[processNewToken]\"], [\n        connection\n    ]);\n    // Light polling backup method\n    const pollForNewMints = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[pollForNewMints]\": async ()=>{\n            try {\n                const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                // Check recent signatures (light method)\n                try {\n                    const signatures = await activeConnection.getSignaturesForAddress(_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.TOKEN_PROGRAM_ID, {\n                        limit: 5\n                    });\n                    setPollingResults(signatures.length);\n                } catch (error) {\n                    setPollingResults({\n                        \"useMintDetection.useCallback[pollForNewMints]\": (prev)=>prev + 1\n                    }[\"useMintDetection.useCallback[pollForNewMints]\"]) // Just show activity\n                    ;\n                }\n            } catch (error) {\n            // Silent polling errors\n            }\n        }\n    }[\"useMintDetection.useCallback[pollForNewMints]\"], [\n        connection\n    ]);\n    const startMonitoring = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[startMonitoring]\": async ()=>{\n            if (!isMonitoring || subscriptionId) return;\n            const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n            try {\n                console.log('ðŸ” Starting mint detection with onLogs...');\n                // Test connection\n                const connectionTest = await _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].testConnection();\n                if (!connectionTest) {\n                    throw new Error('Connection test failed');\n                }\n                // Setup transaction logs listener (more precise than account changes)\n                console.log('ðŸ“¡ Setting up onLogs listener for InitializeMint...');\n                const id = activeConnection.onLogs(_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.TOKEN_PROGRAM_ID, {\n                    \"useMintDetection.useCallback[startMonitoring].id\": (logs, context)=>{\n                        try {\n                            processNewToken(logs, context);\n                        } catch (error) {\n                            console.error('Error in processNewToken:', error);\n                        }\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].id\"], 'confirmed');\n                setSubscriptionId(id);\n                setIsConnected(true);\n                console.log('âœ… onLogs monitoring started - ID:', id);\n                console.log('ðŸŽ¯ Listening for InitializeMint transactions');\n                console.log('ðŸ“Š This method is more precise than account changes');\n                // Heartbeat every 30 seconds\n                const heartbeatInterval = setInterval({\n                    \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": ()=>{\n                        setHeartbeatCount({\n                            \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (prev)=>{\n                                const newCount = prev + 1;\n                                setLastHeartbeat(Date.now());\n                                setAccountsProcessed({\n                                    \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (currentCount)=>{\n                                        setPollingResults({\n                                            \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (currentPollingResults)=>{\n                                                console.log(\"\\uD83D\\uDC93 Heartbeat #\".concat(newCount, \" - \").concat(currentCount, \" transactions, \").concat(currentPollingResults, \" activity\"));\n                                                return currentPollingResults;\n                                            }\n                                        }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                                        return currentCount;\n                                    }\n                                }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                                return newCount;\n                            }\n                        }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"], 30000);\n                // Light polling every 2 minutes\n                const pollingInterval = setInterval({\n                    \"useMintDetection.useCallback[startMonitoring].pollingInterval\": ()=>{\n                        pollForNewMints();\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].pollingInterval\"], 120000);\n                setIntervals({\n                    heartbeat: heartbeatInterval,\n                    polling: pollingInterval\n                });\n                // Initial setup\n                setHeartbeatCount(1);\n                setLastHeartbeat(Date.now());\n                pollForNewMints();\n            } catch (error) {\n                console.error('âŒ Failed to start monitoring:', error);\n                setIsConnected(false);\n            }\n        }\n    }[\"useMintDetection.useCallback[startMonitoring]\"], [\n        isMonitoring,\n        subscriptionId,\n        processNewToken,\n        connection,\n        pollForNewMints\n    ]);\n    const stopMonitoring = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[stopMonitoring]\": async ()=>{\n            if (!subscriptionId) return;\n            const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n            try {\n                // Clear intervals\n                if (intervals.heartbeat) clearInterval(intervals.heartbeat);\n                if (intervals.polling) clearInterval(intervals.polling);\n                setIntervals({});\n                // Remove logs subscription\n                activeConnection.removeOnLogsListener(subscriptionId);\n                // Reset state\n                setSubscriptionId(null);\n                setIsConnected(false);\n                setHeartbeatCount(0);\n                setLastHeartbeat(0);\n                setAccountsProcessed(0);\n                setPollingResults(0);\n                console.log('ðŸ›‘ onLogs monitoring stopped');\n            } catch (error) {\n                console.error('Error stopping monitoring:', error);\n            }\n        }\n    }[\"useMintDetection.useCallback[stopMonitoring]\"], [\n        subscriptionId,\n        connection,\n        intervals\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMintDetection.useEffect\": ()=>{\n            if (isMonitoring) {\n                startMonitoring();\n            } else {\n                stopMonitoring();\n            }\n            return ({\n                \"useMintDetection.useEffect\": ()=>{\n                    // Cleanup on unmount\n                    if (intervals.heartbeat) clearInterval(intervals.heartbeat);\n                    if (intervals.polling) clearInterval(intervals.polling);\n                    if (subscriptionId) {\n                        const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                        activeConnection.removeOnLogsListener(subscriptionId);\n                    }\n                }\n            })[\"useMintDetection.useEffect\"];\n        }\n    }[\"useMintDetection.useEffect\"], [\n        isMonitoring,\n        startMonitoring,\n        stopMonitoring\n    ]);\n    const clearDetectedTokens = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[clearDetectedTokens]\": ()=>{\n            setDetectedTokens([]);\n        }\n    }[\"useMintDetection.useCallback[clearDetectedTokens]\"], []);\n    const removeToken = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[removeToken]\": (mint)=>{\n            setDetectedTokens({\n                \"useMintDetection.useCallback[removeToken]\": (prev)=>prev.filter({\n                        \"useMintDetection.useCallback[removeToken]\": (token)=>token.mint !== mint\n                    }[\"useMintDetection.useCallback[removeToken]\"])\n            }[\"useMintDetection.useCallback[removeToken]\"]);\n        }\n    }[\"useMintDetection.useCallback[removeToken]\"], []);\n    return {\n        detectedTokens,\n        isConnected,\n        isMonitoring: Boolean(subscriptionId),\n        heartbeatCount,\n        lastHeartbeat,\n        accountsProcessed,\n        pollingResults,\n        clearDetectedTokens,\n        removeToken\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9ob29rcy91c2VNaW50RGV0ZWN0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3NFQUV3RDtBQUVKO0FBQ087QUFZcEQsTUFBTUssbUJBQW1CLENBQUNDLFlBQStCQztJQUM5RCxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdSLCtDQUFRQSxDQUFhLEVBQUU7SUFDbkUsTUFBTSxDQUFDUyxnQkFBZ0JDLGtCQUFrQixHQUFHViwrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDVyxhQUFhQyxlQUFlLEdBQUdaLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2EsZ0JBQWdCQyxrQkFBa0IsR0FBR2QsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDZSxlQUFlQyxpQkFBaUIsR0FBR2hCLCtDQUFRQSxDQUFTO0lBQzNELE1BQU0sQ0FBQ2lCLG1CQUFtQkMscUJBQXFCLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUMzRCxNQUFNLENBQUNtQixnQkFBZ0JDLGtCQUFrQixHQUFHcEIsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDcUIsV0FBV0MsYUFBYSxHQUFHdEIsK0NBQVFBLENBQTJELENBQUM7SUFFdEcsTUFBTXVCLGtCQUFrQnRCLGtEQUFXQTt5REFBQyxPQUFPdUIsTUFBV0M7WUFDcEQsSUFBSTtnQkFDRiwrQkFBK0I7Z0JBQy9CUDtxRUFBcUJRLENBQUFBLE9BQVFBLE9BQU87O2dCQUVwQyxvREFBb0Q7Z0JBQ3BELE1BQU1DLFVBQVVILEtBQUtBLElBQUksQ0FBQ0ksSUFBSTs2RUFBQyxDQUFDQyxJQUFjQSxFQUFFQyxRQUFRLENBQUM7O2dCQUN6RCxJQUFJLENBQUNILFNBQVM7Z0JBRWRJLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0NSLEtBQUtTLElBQUk7Z0JBQzNERixRQUFRQyxHQUFHLENBQUMsZ0JBQWdCUixLQUFLVSxTQUFTO2dCQUUxQyxJQUFJO29CQUNGLE1BQU1DLG1CQUFtQjlCLGNBQWNGLGtFQUFn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TCxPQUFPO1FBQ0xuRDtRQUNBSTtRQUNBTCxjQUFjeUYsUUFBUXRGO1FBQ3RCSTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBMEU7UUFDQUM7SUFDRjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWV1bTIxL0RvY3VtZW50cy9Qcm9qZWN0ZW4vQXBwcy9zb2xzbmlwZXJib3QvYXBwL2hvb2tzL3VzZU1pbnREZXRlY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnXG5pbXBvcnQgeyBUT0tFTl9QUk9HUkFNX0lEIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nXG5pbXBvcnQgSGVsaXVzQ29ubmVjdGlvbiBmcm9tICcuLi9zZXJ2aWNlcy9IZWxpdXNDb25uZWN0aW9uJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE5ld1Rva2VuIHtcbiAgbWludDogc3RyaW5nXG4gIHRpbWVzdGFtcDogbnVtYmVyXG4gIHNpZ25hdHVyZTogc3RyaW5nXG4gIGNyZWF0b3I/OiBzdHJpbmdcbiAgbmFtZT86IHN0cmluZ1xuICBzeW1ib2w/OiBzdHJpbmdcbiAgc3VwcGx5PzogbnVtYmVyXG59XG5cbmV4cG9ydCBjb25zdCB1c2VNaW50RGV0ZWN0aW9uID0gKGNvbm5lY3Rpb246IENvbm5lY3Rpb24gfCBudWxsLCBpc01vbml0b3Jpbmc6IGJvb2xlYW4pID0+IHtcbiAgY29uc3QgW2RldGVjdGVkVG9rZW5zLCBzZXREZXRlY3RlZFRva2Vuc10gPSB1c2VTdGF0ZTxOZXdUb2tlbltdPihbXSlcbiAgY29uc3QgW3N1YnNjcmlwdGlvbklkLCBzZXRTdWJzY3JpcHRpb25JZF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKVxuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbaGVhcnRiZWF0Q291bnQsIHNldEhlYXJ0YmVhdENvdW50XSA9IHVzZVN0YXRlKDApXG4gIGNvbnN0IFtsYXN0SGVhcnRiZWF0LCBzZXRMYXN0SGVhcnRiZWF0XSA9IHVzZVN0YXRlPG51bWJlcj4oMClcbiAgY29uc3QgW2FjY291bnRzUHJvY2Vzc2VkLCBzZXRBY2NvdW50c1Byb2Nlc3NlZF0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCBbcG9sbGluZ1Jlc3VsdHMsIHNldFBvbGxpbmdSZXN1bHRzXSA9IHVzZVN0YXRlKDApXG4gIGNvbnN0IFtpbnRlcnZhbHMsIHNldEludGVydmFsc10gPSB1c2VTdGF0ZTx7IGhlYXJ0YmVhdD86IE5vZGVKUy5UaW1lb3V0OyBwb2xsaW5nPzogTm9kZUpTLlRpbWVvdXQgfT4oe30pXG5cbiAgY29uc3QgcHJvY2Vzc05ld1Rva2VuID0gdXNlQ2FsbGJhY2soYXN5bmMgKGxvZ3M6IGFueSwgY29udGV4dDogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvdW50IHRyYW5zYWN0aW9uIGxvZyBldmVudHNcbiAgICAgIHNldEFjY291bnRzUHJvY2Vzc2VkKHByZXYgPT4gcHJldiArIDEpXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgdHJhbnNhY3Rpb24gY29udGFpbnMgSW5pdGlhbGl6ZU1pbnRcbiAgICAgIGNvbnN0IGhhc0luaXQgPSBsb2dzLmxvZ3MuZmluZCgobDogc3RyaW5nKSA9PiBsLmluY2x1ZGVzKFwiSW5pdGlhbGl6ZU1pbnRcIikpXG4gICAgICBpZiAoIWhhc0luaXQpIHJldHVyblxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UlCBJbml0aWFsaXplTWludCBkZXRlY3RlZCBpbiBzbG90JywgbG9ncy5zbG90KVxuICAgICAgY29uc29sZS5sb2coJyAgU2lnbmF0dXJlOicsIGxvZ3Muc2lnbmF0dXJlKVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhY3RpdmVDb25uZWN0aW9uID0gY29ubmVjdGlvbiB8fCBIZWxpdXNDb25uZWN0aW9uLmdldFJwY0Nvbm5lY3Rpb24oKVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBwYXJzZWQgdHJhbnNhY3Rpb24gd2l0aCBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25cbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk50gRmV0Y2hpbmcgcGFyc2VkIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgICAgY29uc3QgcGFyc2VkVHggPSBhd2FpdCBhY3RpdmVDb25uZWN0aW9uLmdldFBhcnNlZFRyYW5zYWN0aW9uKFxuICAgICAgICAgIGxvZ3Muc2lnbmF0dXJlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6IFwiY29uZmlybWVkXCIsXG4gICAgICAgICAgICBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb246IDBcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIGlmICghcGFyc2VkVHgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBQYXJzZWQgdHJhbnNhY3Rpb24gbm90IGZvdW5kIGZvciBzaWduYXR1cmU6JywgbG9ncy5zaWduYXR1cmUpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygn8J+ThCBQYXJzZWQgdHJhbnNhY3Rpb24gcmV0cmlldmVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEluc3RydWN0aW9ucyBmb3VuZDonLCBwYXJzZWRUeC50cmFuc2FjdGlvbi5tZXNzYWdlLmluc3RydWN0aW9ucy5sZW5ndGgpXG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgYWxsIGluc3RydWN0aW9ucyB0byBkZWJ1Z1xuICAgICAgICBwYXJzZWRUeC50cmFuc2FjdGlvbi5tZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKChpeDogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgSW5zdHJ1Y3Rpb24gJHtpbmRleH06YCwge1xuICAgICAgICAgICAgcHJvZ3JhbTogaXgucHJvZ3JhbSxcbiAgICAgICAgICAgIHBhcnNlZDogaXgucGFyc2VkPy50eXBlLFxuICAgICAgICAgICAgcHJvZ3JhbUlkOiBpeC5wcm9ncmFtSWQ/LnRvU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGluaXRpYWxpemVNaW50IGluc3RydWN0aW9uXG4gICAgICAgIGNvbnN0IGluaXRJbnN0ciA9IHBhcnNlZFR4LnRyYW5zYWN0aW9uLm1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLmZpbmQoXG4gICAgICAgICAgKGl4OiBhbnkpID0+XG4gICAgICAgICAgICBpeC5wcm9ncmFtID09PSBcInNwbC10b2tlblwiICYmXG4gICAgICAgICAgICBpeC5wYXJzZWQ/LnR5cGUgPT09IFwiaW5pdGlhbGl6ZU1pbnRcIlxuICAgICAgICApIGFzIGFueVxuICAgICAgICBcbiAgICAgICAgaWYgKCFpbml0SW5zdHIgfHwgIWluaXRJbnN0ci5wYXJzZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBpbml0aWFsaXplTWludCBpbnN0cnVjdGlvbiBub3QgZm91bmQgaW4gcGFyc2VkVHgnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIEF2YWlsYWJsZSBzcGwtdG9rZW4gaW5zdHJ1Y3Rpb25zOicpXG4gICAgICAgICAgcGFyc2VkVHgudHJhbnNhY3Rpb24ubWVzc2FnZS5pbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKGl4OiBhbnkpID0+IGl4LnByb2dyYW0gPT09IFwic3BsLXRva2VuXCIpXG4gICAgICAgICAgICAuZm9yRWFjaCgoaXg6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBTUEwgVG9rZW4gaW5zdHJ1Y3Rpb24gJHtpbmRleH06YCwgaXgucGFyc2VkPy50eXBlLCBpeC5wYXJzZWQ/LmluZm8pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmFjdCBtaW50IGFkZHJlc3MgZnJvbSBwYXJzZWQgaW5mb1xuICAgICAgICBjb25zdCBtaW50QWRkcmVzcyA9IGluaXRJbnN0ci5wYXJzZWQuaW5mby5taW50IGFzIHN0cmluZ1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIE5FVyBNSU5UIEFERFJFU1M6JywgbWludEFkZHJlc3MpXG5cbiAgICAgICAgY29uc3QgbmV3VG9rZW46IE5ld1Rva2VuID0ge1xuICAgICAgICAgIG1pbnQ6IG1pbnRBZGRyZXNzLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBzaWduYXR1cmU6IGxvZ3Muc2lnbmF0dXJlLFxuICAgICAgICAgIGNyZWF0b3I6ICdJbml0aWFsaXplTWludCcsXG4gICAgICAgICAgbmFtZTogYFRva2VuLSR7bWludEFkZHJlc3Muc2xpY2UoMCwgOCl9YCxcbiAgICAgICAgICBzeW1ib2w6ICdORVcnLFxuICAgICAgICAgIHN1cHBseTogMFxuICAgICAgICB9XG5cbiAgICAgICAgc2V0RGV0ZWN0ZWRUb2tlbnMocHJldiA9PiB7XG4gICAgICAgICAgY29uc3QgaXNEdXBsaWNhdGUgPSBwcmV2LnNvbWUodG9rZW4gPT4gdG9rZW4ubWludCA9PT0gbWludEFkZHJlc3MpXG4gICAgICAgICAgaWYgKGlzRHVwbGljYXRlKSByZXR1cm4gcHJldlxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46JIE5FVyBUT0tFTiBBRERFRDonLCBtaW50QWRkcmVzcylcbiAgICAgICAgICByZXR1cm4gW25ld1Rva2VuLCAuLi5wcmV2XS5zbGljZSgwLCAyMClcbiAgICAgICAgfSlcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBFcnJvciBwcm9jZXNzaW5nIHRyYW5zYWN0aW9uOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIG1pbnQgZGV0ZWN0aW9uOicsIGVycm9yKVxuICAgIH1cbiAgfSwgW2Nvbm5lY3Rpb25dKVxuXG4gIC8vIExpZ2h0IHBvbGxpbmcgYmFja3VwIG1ldGhvZFxuICBjb25zdCBwb2xsRm9yTmV3TWludHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUNvbm5lY3Rpb24gPSBjb25uZWN0aW9uIHx8IEhlbGl1c0Nvbm5lY3Rpb24uZ2V0UnBjQ29ubmVjdGlvbigpXG4gICAgICBcbiAgICAgIC8vIENoZWNrIHJlY2VudCBzaWduYXR1cmVzIChsaWdodCBtZXRob2QpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gYXdhaXQgYWN0aXZlQ29ubmVjdGlvbi5nZXRTaWduYXR1cmVzRm9yQWRkcmVzcyhcbiAgICAgICAgICBUT0tFTl9QUk9HUkFNX0lELFxuICAgICAgICAgIHsgbGltaXQ6IDUgfVxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBzZXRQb2xsaW5nUmVzdWx0cyhzaWduYXR1cmVzLmxlbmd0aClcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZXRQb2xsaW5nUmVzdWx0cyhwcmV2ID0+IHByZXYgKyAxKSAvLyBKdXN0IHNob3cgYWN0aXZpdHlcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBTaWxlbnQgcG9sbGluZyBlcnJvcnNcbiAgICB9XG4gIH0sIFtjb25uZWN0aW9uXSlcblxuICBjb25zdCBzdGFydE1vbml0b3JpbmcgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc01vbml0b3JpbmcgfHwgc3Vic2NyaXB0aW9uSWQpIHJldHVyblxuXG4gICAgY29uc3QgYWN0aXZlQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb24gfHwgSGVsaXVzQ29ubmVjdGlvbi5nZXRScGNDb25uZWN0aW9uKClcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBTdGFydGluZyBtaW50IGRldGVjdGlvbiB3aXRoIG9uTG9ncy4uLicpXG4gICAgICBcbiAgICAgIC8vIFRlc3QgY29ubmVjdGlvblxuICAgICAgY29uc3QgY29ubmVjdGlvblRlc3QgPSBhd2FpdCBIZWxpdXNDb25uZWN0aW9uLnRlc3RDb25uZWN0aW9uKClcbiAgICAgIGlmICghY29ubmVjdGlvblRlc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uIHRlc3QgZmFpbGVkJylcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dXAgdHJhbnNhY3Rpb24gbG9ncyBsaXN0ZW5lciAobW9yZSBwcmVjaXNlIHRoYW4gYWNjb3VudCBjaGFuZ2VzKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk6EgU2V0dGluZyB1cCBvbkxvZ3MgbGlzdGVuZXIgZm9yIEluaXRpYWxpemVNaW50Li4uJylcbiAgICAgIGNvbnN0IGlkID0gYWN0aXZlQ29ubmVjdGlvbi5vbkxvZ3MoXG4gICAgICAgIFRPS0VOX1BST0dSQU1fSUQsXG4gICAgICAgIChsb2dzOiBhbnksIGNvbnRleHQ6IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9jZXNzTmV3VG9rZW4obG9ncywgY29udGV4dClcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcHJvY2Vzc05ld1Rva2VuOicsIGVycm9yKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbmZpcm1lZCdcbiAgICAgIClcblxuICAgICAgc2V0U3Vic2NyaXB0aW9uSWQoaWQpXG4gICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBvbkxvZ3MgbW9uaXRvcmluZyBzdGFydGVkIC0gSUQ6JywgaWQpXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBMaXN0ZW5pbmcgZm9yIEluaXRpYWxpemVNaW50IHRyYW5zYWN0aW9ucycpXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBUaGlzIG1ldGhvZCBpcyBtb3JlIHByZWNpc2UgdGhhbiBhY2NvdW50IGNoYW5nZXMnKVxuICAgICAgXG4gICAgICAvLyBIZWFydGJlYXQgZXZlcnkgMzAgc2Vjb25kc1xuICAgICAgY29uc3QgaGVhcnRiZWF0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHNldEhlYXJ0YmVhdENvdW50KHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0NvdW50ID0gcHJldiArIDFcbiAgICAgICAgICBzZXRMYXN0SGVhcnRiZWF0KERhdGUubm93KCkpXG4gICAgICAgICAgXG4gICAgICAgICAgc2V0QWNjb3VudHNQcm9jZXNzZWQoY3VycmVudENvdW50ID0+IHtcbiAgICAgICAgICAgIHNldFBvbGxpbmdSZXN1bHRzKGN1cnJlbnRQb2xsaW5nUmVzdWx0cyA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5KTIEhlYXJ0YmVhdCAjJHtuZXdDb3VudH0gLSAke2N1cnJlbnRDb3VudH0gdHJhbnNhY3Rpb25zLCAke2N1cnJlbnRQb2xsaW5nUmVzdWx0c30gYWN0aXZpdHlgKVxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFBvbGxpbmdSZXN1bHRzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb3VudFxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG5ld0NvdW50XG4gICAgICAgIH0pXG4gICAgICB9LCAzMDAwMClcblxuICAgICAgLy8gTGlnaHQgcG9sbGluZyBldmVyeSAyIG1pbnV0ZXNcbiAgICAgIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgcG9sbEZvck5ld01pbnRzKClcbiAgICAgIH0sIDEyMDAwMClcblxuICAgICAgc2V0SW50ZXJ2YWxzKHsgaGVhcnRiZWF0OiBoZWFydGJlYXRJbnRlcnZhbCwgcG9sbGluZzogcG9sbGluZ0ludGVydmFsIH0pXG4gICAgICBcbiAgICAgIC8vIEluaXRpYWwgc2V0dXBcbiAgICAgIHNldEhlYXJ0YmVhdENvdW50KDEpXG4gICAgICBzZXRMYXN0SGVhcnRiZWF0KERhdGUubm93KCkpXG4gICAgICBwb2xsRm9yTmV3TWludHMoKVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RhcnQgbW9uaXRvcmluZzonLCBlcnJvcilcbiAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxuICAgIH1cbiAgfSwgW2lzTW9uaXRvcmluZywgc3Vic2NyaXB0aW9uSWQsIHByb2Nlc3NOZXdUb2tlbiwgY29ubmVjdGlvbiwgcG9sbEZvck5ld01pbnRzXSlcblxuICBjb25zdCBzdG9wTW9uaXRvcmluZyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbklkKSByZXR1cm5cblxuICAgIGNvbnN0IGFjdGl2ZUNvbm5lY3Rpb24gPSBjb25uZWN0aW9uIHx8IEhlbGl1c0Nvbm5lY3Rpb24uZ2V0UnBjQ29ubmVjdGlvbigpXG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2xlYXIgaW50ZXJ2YWxzXG4gICAgICBpZiAoaW50ZXJ2YWxzLmhlYXJ0YmVhdCkgY2xlYXJJbnRlcnZhbChpbnRlcnZhbHMuaGVhcnRiZWF0KVxuICAgICAgaWYgKGludGVydmFscy5wb2xsaW5nKSBjbGVhckludGVydmFsKGludGVydmFscy5wb2xsaW5nKVxuICAgICAgc2V0SW50ZXJ2YWxzKHt9KVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgbG9ncyBzdWJzY3JpcHRpb25cbiAgICAgIGFjdGl2ZUNvbm5lY3Rpb24ucmVtb3ZlT25Mb2dzTGlzdGVuZXIoc3Vic2NyaXB0aW9uSWQpXG4gICAgICBcbiAgICAgIC8vIFJlc2V0IHN0YXRlXG4gICAgICBzZXRTdWJzY3JpcHRpb25JZChudWxsKVxuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXG4gICAgICBzZXRIZWFydGJlYXRDb3VudCgwKVxuICAgICAgc2V0TGFzdEhlYXJ0YmVhdCgwKVxuICAgICAgc2V0QWNjb3VudHNQcm9jZXNzZWQoMClcbiAgICAgIHNldFBvbGxpbmdSZXN1bHRzKDApXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5uRIG9uTG9ncyBtb25pdG9yaW5nIHN0b3BwZWQnKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdG9wcGluZyBtb25pdG9yaW5nOicsIGVycm9yKVxuICAgIH1cbiAgfSwgW3N1YnNjcmlwdGlvbklkLCBjb25uZWN0aW9uLCBpbnRlcnZhbHNdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzTW9uaXRvcmluZykge1xuICAgICAgc3RhcnRNb25pdG9yaW5nKClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcE1vbml0b3JpbmcoKVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbnVwIG9uIHVubW91bnRcbiAgICAgIGlmIChpbnRlcnZhbHMuaGVhcnRiZWF0KSBjbGVhckludGVydmFsKGludGVydmFscy5oZWFydGJlYXQpXG4gICAgICBpZiAoaW50ZXJ2YWxzLnBvbGxpbmcpIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxzLnBvbGxpbmcpXG4gICAgICBpZiAoc3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb24gfHwgSGVsaXVzQ29ubmVjdGlvbi5nZXRScGNDb25uZWN0aW9uKClcbiAgICAgICAgYWN0aXZlQ29ubmVjdGlvbi5yZW1vdmVPbkxvZ3NMaXN0ZW5lcihzdWJzY3JpcHRpb25JZClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpc01vbml0b3JpbmcsIHN0YXJ0TW9uaXRvcmluZywgc3RvcE1vbml0b3JpbmddKVxuXG4gIGNvbnN0IGNsZWFyRGV0ZWN0ZWRUb2tlbnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0RGV0ZWN0ZWRUb2tlbnMoW10pXG4gIH0sIFtdKVxuXG4gIGNvbnN0IHJlbW92ZVRva2VuID0gdXNlQ2FsbGJhY2soKG1pbnQ6IHN0cmluZykgPT4ge1xuICAgIHNldERldGVjdGVkVG9rZW5zKHByZXYgPT4gcHJldi5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubWludCAhPT0gbWludCkpXG4gIH0sIFtdKVxuXG4gIHJldHVybiB7XG4gICAgZGV0ZWN0ZWRUb2tlbnMsXG4gICAgaXNDb25uZWN0ZWQsXG4gICAgaXNNb25pdG9yaW5nOiBCb29sZWFuKHN1YnNjcmlwdGlvbklkKSxcbiAgICBoZWFydGJlYXRDb3VudCxcbiAgICBsYXN0SGVhcnRiZWF0LFxuICAgIGFjY291bnRzUHJvY2Vzc2VkLFxuICAgIHBvbGxpbmdSZXN1bHRzLFxuICAgIGNsZWFyRGV0ZWN0ZWRUb2tlbnMsXG4gICAgcmVtb3ZlVG9rZW5cbiAgfVxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiVE9LRU5fUFJPR1JBTV9JRCIsIkhlbGl1c0Nvbm5lY3Rpb24iLCJ1c2VNaW50RGV0ZWN0aW9uIiwiY29ubmVjdGlvbiIsImlzTW9uaXRvcmluZyIsImRldGVjdGVkVG9rZW5zIiwic2V0RGV0ZWN0ZWRUb2tlbnMiLCJzdWJzY3JpcHRpb25JZCIsInNldFN1YnNjcmlwdGlvbklkIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImhlYXJ0YmVhdENvdW50Iiwic2V0SGVhcnRiZWF0Q291bnQiLCJsYXN0SGVhcnRiZWF0Iiwic2V0TGFzdEhlYXJ0YmVhdCIsImFjY291bnRzUHJvY2Vzc2VkIiwic2V0QWNjb3VudHNQcm9jZXNzZWQiLCJwb2xsaW5nUmVzdWx0cyIsInNldFBvbGxpbmdSZXN1bHRzIiwiaW50ZXJ2YWxzIiwic2V0SW50ZXJ2YWxzIiwicHJvY2Vzc05ld1Rva2VuIiwibG9ncyIsImNvbnRleHQiLCJwcmV2IiwiaGFzSW5pdCIsImZpbmQiLCJsIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwibG9nIiwic2xvdCIsInNpZ25hdHVyZSIsImFjdGl2ZUNvbm5lY3Rpb24iLCJnZXRScGNDb25uZWN0aW9uIiwicGFyc2VkVHgiLCJnZXRQYXJzZWRUcmFuc2FjdGlvbiIsImNvbW1pdG1lbnQiLCJtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb24iLCJ3YXJuIiwidHJhbnNhY3Rpb24iLCJtZXNzYWdlIiwiaW5zdHJ1Y3Rpb25zIiwibGVuZ3RoIiwiZm9yRWFjaCIsIml4IiwiaW5kZXgiLCJwcm9ncmFtIiwicGFyc2VkIiwidHlwZSIsInByb2dyYW1JZCIsInRvU3RyaW5nIiwiaW5pdEluc3RyIiwiZmlsdGVyIiwiaW5mbyIsIm1pbnRBZGRyZXNzIiwibWludCIsIm5ld1Rva2VuIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImNyZWF0b3IiLCJuYW1lIiwic2xpY2UiLCJzeW1ib2wiLCJzdXBwbHkiLCJpc0R1cGxpY2F0ZSIsInNvbWUiLCJ0b2tlbiIsImVycm9yIiwicG9sbEZvck5ld01pbnRzIiwic2lnbmF0dXJlcyIsImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzIiwibGltaXQiLCJzdGFydE1vbml0b3JpbmciLCJjb25uZWN0aW9uVGVzdCIsInRlc3RDb25uZWN0aW9uIiwiRXJyb3IiLCJpZCIsIm9uTG9ncyIsImhlYXJ0YmVhdEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJuZXdDb3VudCIsImN1cnJlbnRDb3VudCIsImN1cnJlbnRQb2xsaW5nUmVzdWx0cyIsInBvbGxpbmdJbnRlcnZhbCIsImhlYXJ0YmVhdCIsInBvbGxpbmciLCJzdG9wTW9uaXRvcmluZyIsImNsZWFySW50ZXJ2YWwiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsImNsZWFyRGV0ZWN0ZWRUb2tlbnMiLCJyZW1vdmVUb2tlbiIsIkJvb2xlYW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/hooks/useMintDetection.ts\n"));

/***/ })

});