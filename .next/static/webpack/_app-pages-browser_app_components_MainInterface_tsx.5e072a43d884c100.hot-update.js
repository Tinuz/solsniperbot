"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_components_MainInterface_tsx",{

/***/ "(app-pages-browser)/./app/hooks/useMintDetection.ts":
/*!***************************************!*\
  !*** ./app/hooks/useMintDetection.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMintDetection: () => (/* binding */ useMintDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_spl_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/spl-token */ \"(app-pages-browser)/./node_modules/@solana/spl-token/lib/esm/constants.js\");\n/* harmony import */ var _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/HeliusConnection */ \"(app-pages-browser)/./app/services/HeliusConnection.ts\");\n/* __next_internal_client_entry_do_not_use__ useMintDetection auto */ \n\n\nconst useMintDetection = (connection, isMonitoring)=>{\n    const [detectedTokens, setDetectedTokens] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [subscriptionId, setSubscriptionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [heartbeatCount, setHeartbeatCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [lastHeartbeat, setLastHeartbeat] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [accountsProcessed, setAccountsProcessed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [pollingResults, setPollingResults] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [intervals, setIntervals] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const processNewToken = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[processNewToken]\": async (logs, context)=>{\n            try {\n                // Count transaction log events\n                setAccountsProcessed({\n                    \"useMintDetection.useCallback[processNewToken]\": (prev)=>prev + 1\n                }[\"useMintDetection.useCallback[processNewToken]\"]);\n                // Check if this transaction contains InitializeMint\n                const hasInit = logs.logs.find({\n                    \"useMintDetection.useCallback[processNewToken].hasInit\": (l)=>l.includes(\"InitializeMint\")\n                }[\"useMintDetection.useCallback[processNewToken].hasInit\"]);\n                if (!hasInit) return;\n                console.log('üîî InitializeMint detected in slot', logs.slot);\n                console.log('  Signature:', logs.signature);\n                try {\n                    const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                    // Get the parsed transaction with maxSupportedTransactionVersion\n                    console.log('üìù Fetching parsed transaction...');\n                    const parsedTx = await activeConnection.getParsedTransaction(logs.signature, {\n                        commitment: \"confirmed\",\n                        maxSupportedTransactionVersion: 0\n                    });\n                    if (!parsedTx) {\n                        console.warn('‚ö†Ô∏è Parsed transaction not found for signature:', logs.signature);\n                        return;\n                    }\n                    console.log('üìÑ Parsed transaction retrieved successfully');\n                    console.log('üìã Instructions found:', parsedTx.transaction.message.instructions.length);\n                    // Log all instructions to debug\n                    parsedTx.transaction.message.instructions.forEach({\n                        \"useMintDetection.useCallback[processNewToken]\": (ix, index)=>{\n                            var _ix_parsed, _ix_programId;\n                            console.log(\"  Instruction \".concat(index, \":\"), {\n                                program: ix.program,\n                                parsed: (_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type,\n                                programId: (_ix_programId = ix.programId) === null || _ix_programId === void 0 ? void 0 : _ix_programId.toString()\n                            });\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken]\"]);\n                    // Find the initializeMint instruction\n                    const initInstr = parsedTx.transaction.message.instructions.find({\n                        \"useMintDetection.useCallback[processNewToken].initInstr\": (ix)=>{\n                            var _ix_parsed;\n                            return ix.program === \"spl-token\" && ((_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type) === \"initializeMint\";\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken].initInstr\"]);\n                    if (!initInstr || !initInstr.parsed) {\n                        console.warn('‚ö†Ô∏è initializeMint instruction not found in parsedTx');\n                        console.log('üìù Available spl-token instructions:');\n                        parsedTx.transaction.message.instructions.filter({\n                            \"useMintDetection.useCallback[processNewToken]\": (ix)=>ix.program === \"spl-token\"\n                        }[\"useMintDetection.useCallback[processNewToken]\"]).forEach({\n                            \"useMintDetection.useCallback[processNewToken]\": (ix, index)=>{\n                                var _ix_parsed, _ix_parsed1;\n                                console.log(\"  SPL Token instruction \".concat(index, \":\"), (_ix_parsed = ix.parsed) === null || _ix_parsed === void 0 ? void 0 : _ix_parsed.type, (_ix_parsed1 = ix.parsed) === null || _ix_parsed1 === void 0 ? void 0 : _ix_parsed1.info);\n                            }\n                        }[\"useMintDetection.useCallback[processNewToken]\"]);\n                        return;\n                    }\n                    // Extract mint address from parsed info\n                    const mintAddress = initInstr.parsed.info.mint;\n                    console.log('‚úÖ NEW MINT ADDRESS:', mintAddress);\n                    console.log('üìã Full instruction info:', initInstr.parsed.info);\n                    const newToken = {\n                        mint: mintAddress,\n                        timestamp: Date.now(),\n                        signature: logs.signature,\n                        creator: 'InitializeMint',\n                        name: \"Token-\".concat(mintAddress.slice(0, 8)),\n                        symbol: 'NEW',\n                        supply: 0\n                    };\n                    console.log('üîÑ Adding token to state:', newToken);\n                    setDetectedTokens({\n                        \"useMintDetection.useCallback[processNewToken]\": (prev)=>{\n                            console.log('üìä Current tokens in state:', prev.length);\n                            const isDuplicate = prev.some({\n                                \"useMintDetection.useCallback[processNewToken].isDuplicate\": (token)=>token.mint === mintAddress\n                            }[\"useMintDetection.useCallback[processNewToken].isDuplicate\"]);\n                            if (isDuplicate) {\n                                console.log('‚ö†Ô∏è Duplicate token detected, skipping:', mintAddress);\n                                return prev;\n                            }\n                            console.log('üéâ NEW TOKEN ADDED TO STATE:', mintAddress);\n                            const newState = [\n                                newToken,\n                                ...prev\n                            ].slice(0, 20);\n                            console.log('üìä New state length:', newState.length);\n                            return newState;\n                        }\n                    }[\"useMintDetection.useCallback[processNewToken]\"]);\n                } catch (error) {\n                    console.log('‚ö†Ô∏è Error processing transaction:', error);\n                    console.log('üìã Error details:', {\n                        message: error instanceof Error ? error.message : 'Unknown error',\n                        stack: error instanceof Error ? error.stack : undefined,\n                        signature: logs.signature\n                    });\n                }\n            } catch (error) {\n                console.error('Error processing mint detection:', error);\n                console.error('üìã Outer error details:', {\n                    message: error instanceof Error ? error.message : 'Unknown error',\n                    logs: logs\n                });\n            }\n        }\n    }[\"useMintDetection.useCallback[processNewToken]\"], [\n        connection\n    ]);\n    // Light polling backup method\n    const pollForNewMints = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[pollForNewMints]\": async ()=>{\n            try {\n                const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                // Check recent signatures (light method)\n                try {\n                    const signatures = await activeConnection.getSignaturesForAddress(_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.TOKEN_PROGRAM_ID, {\n                        limit: 5\n                    });\n                    setPollingResults(signatures.length);\n                } catch (error) {\n                    setPollingResults({\n                        \"useMintDetection.useCallback[pollForNewMints]\": (prev)=>prev + 1\n                    }[\"useMintDetection.useCallback[pollForNewMints]\"]) // Just show activity\n                    ;\n                }\n            } catch (error) {\n            // Silent polling errors\n            }\n        }\n    }[\"useMintDetection.useCallback[pollForNewMints]\"], [\n        connection\n    ]);\n    const startMonitoring = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[startMonitoring]\": async ()=>{\n            if (!isMonitoring || subscriptionId) return;\n            const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n            try {\n                console.log('üîç Starting mint detection with onLogs...');\n                // Test connection\n                const connectionTest = await _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].testConnection();\n                if (!connectionTest) {\n                    throw new Error('Connection test failed');\n                }\n                // Setup transaction logs listener (more precise than account changes)\n                console.log('üì° Setting up onLogs listener for InitializeMint...');\n                const id = activeConnection.onLogs(_solana_spl_token__WEBPACK_IMPORTED_MODULE_2__.TOKEN_PROGRAM_ID, {\n                    \"useMintDetection.useCallback[startMonitoring].id\": (logs, context)=>{\n                        try {\n                            processNewToken(logs, context);\n                        } catch (error) {\n                            console.error('Error in processNewToken:', error);\n                        }\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].id\"], 'confirmed');\n                setSubscriptionId(id);\n                setIsConnected(true);\n                console.log('‚úÖ onLogs monitoring started - ID:', id);\n                console.log('üéØ Listening for InitializeMint transactions');\n                console.log('üìä This method is more precise than account changes');\n                // Heartbeat every 30 seconds\n                const heartbeatInterval = setInterval({\n                    \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": ()=>{\n                        setHeartbeatCount({\n                            \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (prev)=>{\n                                const newCount = prev + 1;\n                                setLastHeartbeat(Date.now());\n                                setAccountsProcessed({\n                                    \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (currentCount)=>{\n                                        setPollingResults({\n                                            \"useMintDetection.useCallback[startMonitoring].heartbeatInterval\": (currentPollingResults)=>{\n                                                console.log(\"\\uD83D\\uDC93 Heartbeat #\".concat(newCount, \" - \").concat(currentCount, \" transactions, \").concat(currentPollingResults, \" activity\"));\n                                                return currentPollingResults;\n                                            }\n                                        }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                                        return currentCount;\n                                    }\n                                }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                                return newCount;\n                            }\n                        }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"]);\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].heartbeatInterval\"], 30000);\n                // Light polling every 2 minutes\n                const pollingInterval = setInterval({\n                    \"useMintDetection.useCallback[startMonitoring].pollingInterval\": ()=>{\n                        pollForNewMints();\n                    }\n                }[\"useMintDetection.useCallback[startMonitoring].pollingInterval\"], 120000);\n                setIntervals({\n                    heartbeat: heartbeatInterval,\n                    polling: pollingInterval\n                });\n                // Initial setup\n                setHeartbeatCount(1);\n                setLastHeartbeat(Date.now());\n                pollForNewMints();\n            } catch (error) {\n                console.error('‚ùå Failed to start monitoring:', error);\n                setIsConnected(false);\n            }\n        }\n    }[\"useMintDetection.useCallback[startMonitoring]\"], [\n        isMonitoring,\n        subscriptionId,\n        processNewToken,\n        connection,\n        pollForNewMints\n    ]);\n    const stopMonitoring = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[stopMonitoring]\": async ()=>{\n            if (!subscriptionId) return;\n            const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n            try {\n                // Clear intervals\n                if (intervals.heartbeat) clearInterval(intervals.heartbeat);\n                if (intervals.polling) clearInterval(intervals.polling);\n                setIntervals({});\n                // Remove logs subscription\n                activeConnection.removeOnLogsListener(subscriptionId);\n                // Reset state\n                setSubscriptionId(null);\n                setIsConnected(false);\n                setHeartbeatCount(0);\n                setLastHeartbeat(0);\n                setAccountsProcessed(0);\n                setPollingResults(0);\n                console.log('üõë onLogs monitoring stopped');\n            } catch (error) {\n                console.error('Error stopping monitoring:', error);\n            }\n        }\n    }[\"useMintDetection.useCallback[stopMonitoring]\"], [\n        subscriptionId,\n        connection,\n        intervals\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMintDetection.useEffect\": ()=>{\n            if (isMonitoring) {\n                startMonitoring();\n            } else {\n                stopMonitoring();\n            }\n            return ({\n                \"useMintDetection.useEffect\": ()=>{\n                    // Cleanup on unmount\n                    if (intervals.heartbeat) clearInterval(intervals.heartbeat);\n                    if (intervals.polling) clearInterval(intervals.polling);\n                    if (subscriptionId) {\n                        const activeConnection = connection || _services_HeliusConnection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRpcConnection();\n                        activeConnection.removeOnLogsListener(subscriptionId);\n                    }\n                }\n            })[\"useMintDetection.useEffect\"];\n        }\n    }[\"useMintDetection.useEffect\"], [\n        isMonitoring,\n        startMonitoring,\n        stopMonitoring\n    ]);\n    const clearDetectedTokens = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[clearDetectedTokens]\": ()=>{\n            setDetectedTokens([]);\n        }\n    }[\"useMintDetection.useCallback[clearDetectedTokens]\"], []);\n    const removeToken = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMintDetection.useCallback[removeToken]\": (mint)=>{\n            setDetectedTokens({\n                \"useMintDetection.useCallback[removeToken]\": (prev)=>prev.filter({\n                        \"useMintDetection.useCallback[removeToken]\": (token)=>token.mint !== mint\n                    }[\"useMintDetection.useCallback[removeToken]\"])\n            }[\"useMintDetection.useCallback[removeToken]\"]);\n        }\n    }[\"useMintDetection.useCallback[removeToken]\"], []);\n    return {\n        detectedTokens,\n        isConnected,\n        isMonitoring: Boolean(subscriptionId),\n        heartbeatCount,\n        lastHeartbeat,\n        accountsProcessed,\n        pollingResults,\n        clearDetectedTokens,\n        removeToken\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9ob29rcy91c2VNaW50RGV0ZWN0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3NFQUV3RDtBQUVKO0FBQ087QUFZcEQsTUFBTUssbUJBQW1CLENBQUNDLFlBQStCQztJQUM5RCxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdSLCtDQUFRQSxDQUFhLEVBQUU7SUFDbkUsTUFBTSxDQUFDUyxnQkFBZ0JDLGtCQUFrQixHQUFHViwrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDVyxhQUFhQyxlQUFlLEdBQUdaLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2EsZ0JBQWdCQyxrQkFBa0IsR0FBR2QsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDZSxlQUFlQyxpQkFBaUIsR0FBR2hCLCtDQUFRQSxDQUFTO0lBQzNELE1BQU0sQ0FBQ2lCLG1CQUFtQkMscUJBQXFCLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUMzRCxNQUFNLENBQUNtQixnQkFBZ0JDLGtCQUFrQixHQUFHcEIsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDcUIsV0FBV0MsYUFBYSxHQUFHdEIsK0NBQVFBLENBQTJELENBQUM7SUFFdEcsTUFBTXVCLGtCQUFrQnRCLGtEQUFXQTt5REFBQyxPQUFPdUIsTUFBV0M7WUFDcEQsSUFBSTtnQkFDRiwrQkFBK0I7Z0JBQy9CUDtxRUFBcUJRLENBQUFBLE9BQVFBLE9BQU87O2dCQUVwQyxvREFBb0Q7Z0JBQ3BELE1BQU1DLFVBQVVILEtBQUtBLElBQUksQ0FBQ0ksSUFBSTs2RUFBQyxDQUFDQyxJQUFjQSxFQUFFQyxRQUFRLENBQUM7O2dCQUN6RCxJQUFJLENBQUNILFNBQVM7Z0JBRWRJLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0NSLEtBQUtTLElBQUk7Z0JBQzNERixRQUFRQyxHQUFHLENBQUMsZ0JBQWdCUixLQUFLVSxTQUFTO2dCQUUxQyxJQUFJO29CQUNGLE1BQU1DLG1CQUFtQjlCLGNBQWNGLGtFQUFn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TztnQkFDTGE7WUFDRjtZQUVBOzhDQUFPO29CQUNMLHFCQUFxQjtvQkFDckIsSUFBSXhFLFVBQVVzRSxTQUFTLEVBQUVHLGNBQWN6RSxVQUFVc0UsU0FBUztvQkFDMUQsSUFBSXRFLFVBQVV1RSxPQUFPLEVBQUVFLGNBQWN6RSxVQUFVdUUsT0FBTztvQkFDdEQsSUFBSW5GLGdCQUFnQjt3QkFDbEIsTUFBTTBCLG1CQUFtQjlCLGNBQWNGLGtFQUFnQkEsQ0FBQ2lDLGdCQUFnQjt3QkFDeEVELGlCQUFpQjRELG9CQUFvQixDQUFDdEY7b0JBQ3hDO2dCQUNGOztRQUNGO3FDQUFHO1FBQUNIO1FBQWMwRTtRQUFpQmE7S0FBZTtJQUVsRCxNQUFNRyxzQkFBc0IvRixrREFBV0E7NkRBQUM7WUFDdENPLGtCQUFrQixFQUFFO1FBQ3RCOzREQUFHLEVBQUU7SUFFTCxNQUFNeUYsY0FBY2hHLGtEQUFXQTtxREFBQyxDQUFDeUQ7WUFDL0JsRDs2REFBa0JrQixDQUFBQSxPQUFRQSxLQUFLNkIsTUFBTTtxRUFBQ2UsQ0FBQUEsUUFBU0EsTUFBTVosSUFBSSxLQUFLQTs7O1FBQ2hFO29EQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0xuRDtRQUNBSTtRQUNBTCxjQUFjNEYsUUFBUXpGO1FBQ3RCSTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBNkU7UUFDQUM7SUFDRjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWV1bTIxL0RvY3VtZW50cy9Qcm9qZWN0ZW4vQXBwcy9zb2xzbmlwZXJib3QvYXBwL2hvb2tzL3VzZU1pbnREZXRlY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnXG5pbXBvcnQgeyBUT0tFTl9QUk9HUkFNX0lEIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nXG5pbXBvcnQgSGVsaXVzQ29ubmVjdGlvbiBmcm9tICcuLi9zZXJ2aWNlcy9IZWxpdXNDb25uZWN0aW9uJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE5ld1Rva2VuIHtcbiAgbWludDogc3RyaW5nXG4gIHRpbWVzdGFtcDogbnVtYmVyXG4gIHNpZ25hdHVyZTogc3RyaW5nXG4gIGNyZWF0b3I/OiBzdHJpbmdcbiAgbmFtZT86IHN0cmluZ1xuICBzeW1ib2w/OiBzdHJpbmdcbiAgc3VwcGx5PzogbnVtYmVyXG59XG5cbmV4cG9ydCBjb25zdCB1c2VNaW50RGV0ZWN0aW9uID0gKGNvbm5lY3Rpb246IENvbm5lY3Rpb24gfCBudWxsLCBpc01vbml0b3Jpbmc6IGJvb2xlYW4pID0+IHtcbiAgY29uc3QgW2RldGVjdGVkVG9rZW5zLCBzZXREZXRlY3RlZFRva2Vuc10gPSB1c2VTdGF0ZTxOZXdUb2tlbltdPihbXSlcbiAgY29uc3QgW3N1YnNjcmlwdGlvbklkLCBzZXRTdWJzY3JpcHRpb25JZF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKVxuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbaGVhcnRiZWF0Q291bnQsIHNldEhlYXJ0YmVhdENvdW50XSA9IHVzZVN0YXRlKDApXG4gIGNvbnN0IFtsYXN0SGVhcnRiZWF0LCBzZXRMYXN0SGVhcnRiZWF0XSA9IHVzZVN0YXRlPG51bWJlcj4oMClcbiAgY29uc3QgW2FjY291bnRzUHJvY2Vzc2VkLCBzZXRBY2NvdW50c1Byb2Nlc3NlZF0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCBbcG9sbGluZ1Jlc3VsdHMsIHNldFBvbGxpbmdSZXN1bHRzXSA9IHVzZVN0YXRlKDApXG4gIGNvbnN0IFtpbnRlcnZhbHMsIHNldEludGVydmFsc10gPSB1c2VTdGF0ZTx7IGhlYXJ0YmVhdD86IE5vZGVKUy5UaW1lb3V0OyBwb2xsaW5nPzogTm9kZUpTLlRpbWVvdXQgfT4oe30pXG5cbiAgY29uc3QgcHJvY2Vzc05ld1Rva2VuID0gdXNlQ2FsbGJhY2soYXN5bmMgKGxvZ3M6IGFueSwgY29udGV4dDogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvdW50IHRyYW5zYWN0aW9uIGxvZyBldmVudHNcbiAgICAgIHNldEFjY291bnRzUHJvY2Vzc2VkKHByZXYgPT4gcHJldiArIDEpXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgdHJhbnNhY3Rpb24gY29udGFpbnMgSW5pdGlhbGl6ZU1pbnRcbiAgICAgIGNvbnN0IGhhc0luaXQgPSBsb2dzLmxvZ3MuZmluZCgobDogc3RyaW5nKSA9PiBsLmluY2x1ZGVzKFwiSW5pdGlhbGl6ZU1pbnRcIikpXG4gICAgICBpZiAoIWhhc0luaXQpIHJldHVyblxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UlCBJbml0aWFsaXplTWludCBkZXRlY3RlZCBpbiBzbG90JywgbG9ncy5zbG90KVxuICAgICAgY29uc29sZS5sb2coJyAgU2lnbmF0dXJlOicsIGxvZ3Muc2lnbmF0dXJlKVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhY3RpdmVDb25uZWN0aW9uID0gY29ubmVjdGlvbiB8fCBIZWxpdXNDb25uZWN0aW9uLmdldFJwY0Nvbm5lY3Rpb24oKVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBwYXJzZWQgdHJhbnNhY3Rpb24gd2l0aCBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25cbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk50gRmV0Y2hpbmcgcGFyc2VkIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgICAgY29uc3QgcGFyc2VkVHggPSBhd2FpdCBhY3RpdmVDb25uZWN0aW9uLmdldFBhcnNlZFRyYW5zYWN0aW9uKFxuICAgICAgICAgIGxvZ3Muc2lnbmF0dXJlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6IFwiY29uZmlybWVkXCIsXG4gICAgICAgICAgICBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb246IDBcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIGlmICghcGFyc2VkVHgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBQYXJzZWQgdHJhbnNhY3Rpb24gbm90IGZvdW5kIGZvciBzaWduYXR1cmU6JywgbG9ncy5zaWduYXR1cmUpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygn8J+ThCBQYXJzZWQgdHJhbnNhY3Rpb24gcmV0cmlldmVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEluc3RydWN0aW9ucyBmb3VuZDonLCBwYXJzZWRUeC50cmFuc2FjdGlvbi5tZXNzYWdlLmluc3RydWN0aW9ucy5sZW5ndGgpXG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgYWxsIGluc3RydWN0aW9ucyB0byBkZWJ1Z1xuICAgICAgICBwYXJzZWRUeC50cmFuc2FjdGlvbi5tZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKChpeDogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgSW5zdHJ1Y3Rpb24gJHtpbmRleH06YCwge1xuICAgICAgICAgICAgcHJvZ3JhbTogaXgucHJvZ3JhbSxcbiAgICAgICAgICAgIHBhcnNlZDogaXgucGFyc2VkPy50eXBlLFxuICAgICAgICAgICAgcHJvZ3JhbUlkOiBpeC5wcm9ncmFtSWQ/LnRvU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGluaXRpYWxpemVNaW50IGluc3RydWN0aW9uXG4gICAgICAgIGNvbnN0IGluaXRJbnN0ciA9IHBhcnNlZFR4LnRyYW5zYWN0aW9uLm1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLmZpbmQoXG4gICAgICAgICAgKGl4OiBhbnkpID0+XG4gICAgICAgICAgICBpeC5wcm9ncmFtID09PSBcInNwbC10b2tlblwiICYmXG4gICAgICAgICAgICBpeC5wYXJzZWQ/LnR5cGUgPT09IFwiaW5pdGlhbGl6ZU1pbnRcIlxuICAgICAgICApIGFzIGFueVxuICAgICAgICBcbiAgICAgICAgaWYgKCFpbml0SW5zdHIgfHwgIWluaXRJbnN0ci5wYXJzZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBpbml0aWFsaXplTWludCBpbnN0cnVjdGlvbiBub3QgZm91bmQgaW4gcGFyc2VkVHgnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIEF2YWlsYWJsZSBzcGwtdG9rZW4gaW5zdHJ1Y3Rpb25zOicpXG4gICAgICAgICAgcGFyc2VkVHgudHJhbnNhY3Rpb24ubWVzc2FnZS5pbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKGl4OiBhbnkpID0+IGl4LnByb2dyYW0gPT09IFwic3BsLXRva2VuXCIpXG4gICAgICAgICAgICAuZm9yRWFjaCgoaXg6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBTUEwgVG9rZW4gaW5zdHJ1Y3Rpb24gJHtpbmRleH06YCwgaXgucGFyc2VkPy50eXBlLCBpeC5wYXJzZWQ/LmluZm8pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmFjdCBtaW50IGFkZHJlc3MgZnJvbSBwYXJzZWQgaW5mb1xuICAgICAgICBjb25zdCBtaW50QWRkcmVzcyA9IGluaXRJbnN0ci5wYXJzZWQuaW5mby5taW50IGFzIHN0cmluZ1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIE5FVyBNSU5UIEFERFJFU1M6JywgbWludEFkZHJlc3MpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEZ1bGwgaW5zdHJ1Y3Rpb24gaW5mbzonLCBpbml0SW5zdHIucGFyc2VkLmluZm8pXG5cbiAgICAgICAgY29uc3QgbmV3VG9rZW46IE5ld1Rva2VuID0ge1xuICAgICAgICAgIG1pbnQ6IG1pbnRBZGRyZXNzLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBzaWduYXR1cmU6IGxvZ3Muc2lnbmF0dXJlLFxuICAgICAgICAgIGNyZWF0b3I6ICdJbml0aWFsaXplTWludCcsXG4gICAgICAgICAgbmFtZTogYFRva2VuLSR7bWludEFkZHJlc3Muc2xpY2UoMCwgOCl9YCxcbiAgICAgICAgICBzeW1ib2w6ICdORVcnLFxuICAgICAgICAgIHN1cHBseTogMFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/CflIQgQWRkaW5nIHRva2VuIHRvIHN0YXRlOicsIG5ld1Rva2VuKVxuICAgICAgICBcbiAgICAgICAgc2V0RGV0ZWN0ZWRUb2tlbnMocHJldiA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogQ3VycmVudCB0b2tlbnMgaW4gc3RhdGU6JywgcHJldi5sZW5ndGgpXG4gICAgICAgICAgY29uc3QgaXNEdXBsaWNhdGUgPSBwcmV2LnNvbWUodG9rZW4gPT4gdG9rZW4ubWludCA9PT0gbWludEFkZHJlc3MpXG4gICAgICAgICAgaWYgKGlzRHVwbGljYXRlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIER1cGxpY2F0ZSB0b2tlbiBkZXRlY3RlZCwgc2tpcHBpbmc6JywgbWludEFkZHJlc3MpXG4gICAgICAgICAgICByZXR1cm4gcHJldlxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+OiSBORVcgVE9LRU4gQURERUQgVE8gU1RBVEU6JywgbWludEFkZHJlc3MpXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBbbmV3VG9rZW4sIC4uLnByZXZdLnNsaWNlKDAsIDIwKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIE5ldyBzdGF0ZSBsZW5ndGg6JywgbmV3U3RhdGUubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgICAgICB9KVxuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIEVycm9yIHByb2Nlc3NpbmcgdHJhbnNhY3Rpb246JywgZXJyb3IpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEVycm9yIGRldGFpbHM6Jywge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWQsXG4gICAgICAgICAgc2lnbmF0dXJlOiBsb2dzLnNpZ25hdHVyZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIG1pbnQgZGV0ZWN0aW9uOicsIGVycm9yKVxuICAgICAgY29uc29sZS5lcnJvcign8J+TiyBPdXRlciBlcnJvciBkZXRhaWxzOicsIHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgIGxvZ3M6IGxvZ3NcbiAgICAgIH0pXG4gICAgfVxuICB9LCBbY29ubmVjdGlvbl0pXG5cbiAgLy8gTGlnaHQgcG9sbGluZyBiYWNrdXAgbWV0aG9kXG4gIGNvbnN0IHBvbGxGb3JOZXdNaW50cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWN0aXZlQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb24gfHwgSGVsaXVzQ29ubmVjdGlvbi5nZXRScGNDb25uZWN0aW9uKClcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgcmVjZW50IHNpZ25hdHVyZXMgKGxpZ2h0IG1ldGhvZClcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBhd2FpdCBhY3RpdmVDb25uZWN0aW9uLmdldFNpZ25hdHVyZXNGb3JBZGRyZXNzKFxuICAgICAgICAgIFRPS0VOX1BST0dSQU1fSUQsXG4gICAgICAgICAgeyBsaW1pdDogNSB9XG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIHNldFBvbGxpbmdSZXN1bHRzKHNpZ25hdHVyZXMubGVuZ3RoKVxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNldFBvbGxpbmdSZXN1bHRzKHByZXYgPT4gcHJldiArIDEpIC8vIEp1c3Qgc2hvdyBhY3Rpdml0eVxuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFNpbGVudCBwb2xsaW5nIGVycm9yc1xuICAgIH1cbiAgfSwgW2Nvbm5lY3Rpb25dKVxuXG4gIGNvbnN0IHN0YXJ0TW9uaXRvcmluZyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWlzTW9uaXRvcmluZyB8fCBzdWJzY3JpcHRpb25JZCkgcmV0dXJuXG5cbiAgICBjb25zdCBhY3RpdmVDb25uZWN0aW9uID0gY29ubmVjdGlvbiB8fCBIZWxpdXNDb25uZWN0aW9uLmdldFJwY0Nvbm5lY3Rpb24oKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFN0YXJ0aW5nIG1pbnQgZGV0ZWN0aW9uIHdpdGggb25Mb2dzLi4uJylcbiAgICAgIFxuICAgICAgLy8gVGVzdCBjb25uZWN0aW9uXG4gICAgICBjb25zdCBjb25uZWN0aW9uVGVzdCA9IGF3YWl0IEhlbGl1c0Nvbm5lY3Rpb24udGVzdENvbm5lY3Rpb24oKVxuICAgICAgaWYgKCFjb25uZWN0aW9uVGVzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gdGVzdCBmYWlsZWQnKVxuICAgICAgfVxuXG4gICAgICAvLyBTZXR1cCB0cmFuc2FjdGlvbiBsb2dzIGxpc3RlbmVyIChtb3JlIHByZWNpc2UgdGhhbiBhY2NvdW50IGNoYW5nZXMpXG4gICAgICBjb25zb2xlLmxvZygn8J+ToSBTZXR0aW5nIHVwIG9uTG9ncyBsaXN0ZW5lciBmb3IgSW5pdGlhbGl6ZU1pbnQuLi4nKVxuICAgICAgY29uc3QgaWQgPSBhY3RpdmVDb25uZWN0aW9uLm9uTG9ncyhcbiAgICAgICAgVE9LRU5fUFJPR1JBTV9JRCxcbiAgICAgICAgKGxvZ3M6IGFueSwgY29udGV4dDogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2Nlc3NOZXdUb2tlbihsb2dzLCBjb250ZXh0KVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwcm9jZXNzTmV3VG9rZW46JywgZXJyb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnY29uZmlybWVkJ1xuICAgICAgKVxuXG4gICAgICBzZXRTdWJzY3JpcHRpb25JZChpZClcbiAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpXG4gICAgICBjb25zb2xlLmxvZygn4pyFIG9uTG9ncyBtb25pdG9yaW5nIHN0YXJ0ZWQgLSBJRDonLCBpZClcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIExpc3RlbmluZyBmb3IgSW5pdGlhbGl6ZU1pbnQgdHJhbnNhY3Rpb25zJylcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFRoaXMgbWV0aG9kIGlzIG1vcmUgcHJlY2lzZSB0aGFuIGFjY291bnQgY2hhbmdlcycpXG4gICAgICBcbiAgICAgIC8vIEhlYXJ0YmVhdCBldmVyeSAzMCBzZWNvbmRzXG4gICAgICBjb25zdCBoZWFydGJlYXRJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgc2V0SGVhcnRiZWF0Q291bnQocHJldiA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3Q291bnQgPSBwcmV2ICsgMVxuICAgICAgICAgIHNldExhc3RIZWFydGJlYXQoRGF0ZS5ub3coKSlcbiAgICAgICAgICBcbiAgICAgICAgICBzZXRBY2NvdW50c1Byb2Nlc3NlZChjdXJyZW50Q291bnQgPT4ge1xuICAgICAgICAgICAgc2V0UG9sbGluZ1Jlc3VsdHMoY3VycmVudFBvbGxpbmdSZXN1bHRzID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfkpMgSGVhcnRiZWF0ICMke25ld0NvdW50fSAtICR7Y3VycmVudENvdW50fSB0cmFuc2FjdGlvbnMsICR7Y3VycmVudFBvbGxpbmdSZXN1bHRzfSBhY3Rpdml0eWApXG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UG9sbGluZ1Jlc3VsdHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvdW50XG4gICAgICAgICAgfSlcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbmV3Q291bnRcbiAgICAgICAgfSlcbiAgICAgIH0sIDMwMDAwKVxuXG4gICAgICAvLyBMaWdodCBwb2xsaW5nIGV2ZXJ5IDIgbWludXRlc1xuICAgICAgY29uc3QgcG9sbGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBwb2xsRm9yTmV3TWludHMoKVxuICAgICAgfSwgMTIwMDAwKVxuXG4gICAgICBzZXRJbnRlcnZhbHMoeyBoZWFydGJlYXQ6IGhlYXJ0YmVhdEludGVydmFsLCBwb2xsaW5nOiBwb2xsaW5nSW50ZXJ2YWwgfSlcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbCBzZXR1cFxuICAgICAgc2V0SGVhcnRiZWF0Q291bnQoMSlcbiAgICAgIHNldExhc3RIZWFydGJlYXQoRGF0ZS5ub3coKSlcbiAgICAgIHBvbGxGb3JOZXdNaW50cygpXG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzdGFydCBtb25pdG9yaW5nOicsIGVycm9yKVxuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXG4gICAgfVxuICB9LCBbaXNNb25pdG9yaW5nLCBzdWJzY3JpcHRpb25JZCwgcHJvY2Vzc05ld1Rva2VuLCBjb25uZWN0aW9uLCBwb2xsRm9yTmV3TWludHNdKVxuXG4gIGNvbnN0IHN0b3BNb25pdG9yaW5nID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghc3Vic2NyaXB0aW9uSWQpIHJldHVyblxuXG4gICAgY29uc3QgYWN0aXZlQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb24gfHwgSGVsaXVzQ29ubmVjdGlvbi5nZXRScGNDb25uZWN0aW9uKClcblxuICAgIHRyeSB7XG4gICAgICAvLyBDbGVhciBpbnRlcnZhbHNcbiAgICAgIGlmIChpbnRlcnZhbHMuaGVhcnRiZWF0KSBjbGVhckludGVydmFsKGludGVydmFscy5oZWFydGJlYXQpXG4gICAgICBpZiAoaW50ZXJ2YWxzLnBvbGxpbmcpIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxzLnBvbGxpbmcpXG4gICAgICBzZXRJbnRlcnZhbHMoe30pXG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBsb2dzIHN1YnNjcmlwdGlvblxuICAgICAgYWN0aXZlQ29ubmVjdGlvbi5yZW1vdmVPbkxvZ3NMaXN0ZW5lcihzdWJzY3JpcHRpb25JZClcbiAgICAgIFxuICAgICAgLy8gUmVzZXQgc3RhdGVcbiAgICAgIHNldFN1YnNjcmlwdGlvbklkKG51bGwpXG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcbiAgICAgIHNldEhlYXJ0YmVhdENvdW50KDApXG4gICAgICBzZXRMYXN0SGVhcnRiZWF0KDApXG4gICAgICBzZXRBY2NvdW50c1Byb2Nlc3NlZCgwKVxuICAgICAgc2V0UG9sbGluZ1Jlc3VsdHMoMClcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/Cfm5Egb25Mb2dzIG1vbml0b3Jpbmcgc3RvcHBlZCcpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN0b3BwaW5nIG1vbml0b3Jpbmc6JywgZXJyb3IpXG4gICAgfVxuICB9LCBbc3Vic2NyaXB0aW9uSWQsIGNvbm5lY3Rpb24sIGludGVydmFsc10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNNb25pdG9yaW5nKSB7XG4gICAgICBzdGFydE1vbml0b3JpbmcoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wTW9uaXRvcmluZygpXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxuICAgICAgaWYgKGludGVydmFscy5oZWFydGJlYXQpIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxzLmhlYXJ0YmVhdClcbiAgICAgIGlmIChpbnRlcnZhbHMucG9sbGluZykgY2xlYXJJbnRlcnZhbChpbnRlcnZhbHMucG9sbGluZylcbiAgICAgIGlmIChzdWJzY3JpcHRpb25JZCkge1xuICAgICAgICBjb25zdCBhY3RpdmVDb25uZWN0aW9uID0gY29ubmVjdGlvbiB8fCBIZWxpdXNDb25uZWN0aW9uLmdldFJwY0Nvbm5lY3Rpb24oKVxuICAgICAgICBhY3RpdmVDb25uZWN0aW9uLnJlbW92ZU9uTG9nc0xpc3RlbmVyKHN1YnNjcmlwdGlvbklkKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2lzTW9uaXRvcmluZywgc3RhcnRNb25pdG9yaW5nLCBzdG9wTW9uaXRvcmluZ10pXG5cbiAgY29uc3QgY2xlYXJEZXRlY3RlZFRva2VucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXREZXRlY3RlZFRva2VucyhbXSlcbiAgfSwgW10pXG5cbiAgY29uc3QgcmVtb3ZlVG9rZW4gPSB1c2VDYWxsYmFjaygobWludDogc3RyaW5nKSA9PiB7XG4gICAgc2V0RGV0ZWN0ZWRUb2tlbnMocHJldiA9PiBwcmV2LmZpbHRlcih0b2tlbiA9PiB0b2tlbi5taW50ICE9PSBtaW50KSlcbiAgfSwgW10pXG5cbiAgcmV0dXJuIHtcbiAgICBkZXRlY3RlZFRva2VucyxcbiAgICBpc0Nvbm5lY3RlZCxcbiAgICBpc01vbml0b3Jpbmc6IEJvb2xlYW4oc3Vic2NyaXB0aW9uSWQpLFxuICAgIGhlYXJ0YmVhdENvdW50LFxuICAgIGxhc3RIZWFydGJlYXQsXG4gICAgYWNjb3VudHNQcm9jZXNzZWQsXG4gICAgcG9sbGluZ1Jlc3VsdHMsXG4gICAgY2xlYXJEZXRlY3RlZFRva2VucyxcbiAgICByZW1vdmVUb2tlblxuICB9XG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJUT0tFTl9QUk9HUkFNX0lEIiwiSGVsaXVzQ29ubmVjdGlvbiIsInVzZU1pbnREZXRlY3Rpb24iLCJjb25uZWN0aW9uIiwiaXNNb25pdG9yaW5nIiwiZGV0ZWN0ZWRUb2tlbnMiLCJzZXREZXRlY3RlZFRva2VucyIsInN1YnNjcmlwdGlvbklkIiwic2V0U3Vic2NyaXB0aW9uSWQiLCJpc0Nvbm5lY3RlZCIsInNldElzQ29ubmVjdGVkIiwiaGVhcnRiZWF0Q291bnQiLCJzZXRIZWFydGJlYXRDb3VudCIsImxhc3RIZWFydGJlYXQiLCJzZXRMYXN0SGVhcnRiZWF0IiwiYWNjb3VudHNQcm9jZXNzZWQiLCJzZXRBY2NvdW50c1Byb2Nlc3NlZCIsInBvbGxpbmdSZXN1bHRzIiwic2V0UG9sbGluZ1Jlc3VsdHMiLCJpbnRlcnZhbHMiLCJzZXRJbnRlcnZhbHMiLCJwcm9jZXNzTmV3VG9rZW4iLCJsb2dzIiwiY29udGV4dCIsInByZXYiLCJoYXNJbml0IiwiZmluZCIsImwiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJsb2ciLCJzbG90Iiwic2lnbmF0dXJlIiwiYWN0aXZlQ29ubmVjdGlvbiIsImdldFJwY0Nvbm5lY3Rpb24iLCJwYXJzZWRUeCIsImdldFBhcnNlZFRyYW5zYWN0aW9uIiwiY29tbWl0bWVudCIsIm1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbiIsIndhcm4iLCJ0cmFuc2FjdGlvbiIsIm1lc3NhZ2UiLCJpbnN0cnVjdGlvbnMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiaXgiLCJpbmRleCIsInByb2dyYW0iLCJwYXJzZWQiLCJ0eXBlIiwicHJvZ3JhbUlkIiwidG9TdHJpbmciLCJpbml0SW5zdHIiLCJmaWx0ZXIiLCJpbmZvIiwibWludEFkZHJlc3MiLCJtaW50IiwibmV3VG9rZW4iLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwiY3JlYXRvciIsIm5hbWUiLCJzbGljZSIsInN5bWJvbCIsInN1cHBseSIsImlzRHVwbGljYXRlIiwic29tZSIsInRva2VuIiwibmV3U3RhdGUiLCJlcnJvciIsIkVycm9yIiwic3RhY2siLCJ1bmRlZmluZWQiLCJwb2xsRm9yTmV3TWludHMiLCJzaWduYXR1cmVzIiwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJsaW1pdCIsInN0YXJ0TW9uaXRvcmluZyIsImNvbm5lY3Rpb25UZXN0IiwidGVzdENvbm5lY3Rpb24iLCJpZCIsIm9uTG9ncyIsImhlYXJ0YmVhdEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJuZXdDb3VudCIsImN1cnJlbnRDb3VudCIsImN1cnJlbnRQb2xsaW5nUmVzdWx0cyIsInBvbGxpbmdJbnRlcnZhbCIsImhlYXJ0YmVhdCIsInBvbGxpbmciLCJzdG9wTW9uaXRvcmluZyIsImNsZWFySW50ZXJ2YWwiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsImNsZWFyRGV0ZWN0ZWRUb2tlbnMiLCJyZW1vdmVUb2tlbiIsIkJvb2xlYW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/hooks/useMintDetection.ts\n"));

/***/ })

});